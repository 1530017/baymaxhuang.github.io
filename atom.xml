<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dabai的个人博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-28T03:02:18.936Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Dabai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ONOS中ISSU特性的实现和分析</title>
    <link href="http://yoursite.com/2018/01/26/ONOS%E4%B8%ADISSU%E7%89%B9%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/01/26/ONOS中ISSU特性的实现和分析/</id>
    <published>2018-01-26T12:15:40.000Z</published>
    <updated>2018-01-28T03:02:18.936Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h1 id="1-gRPC依赖的OSGi化"><a href="#1-gRPC依赖的OSGi化" class="headerlink" title="1. gRPC依赖的OSGi化"></a>1. gRPC依赖的OSGi化</h1>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-gRPC依赖的OSGi化&quot;&gt;&lt;a href=&quot;#1-gRPC依赖的OSGi化&quot; class=&quot;headerlink&quot; title=&quot;1. gRPC依赖的OSGi化&quot;&gt;&lt;/a&gt;1. gRPC依赖的OSGi化&lt;/h1&gt;
    
    </summary>
    
      <category term="ONOS" scheme="http://yoursite.com/categories/ONOS/"/>
    
    
      <category term="ONOS" scheme="http://yoursite.com/tags/ONOS/"/>
    
      <category term="ISSU" scheme="http://yoursite.com/tags/ISSU/"/>
    
  </entry>
  
  <entry>
    <title>ONOS中基于gRPC应用的实现</title>
    <link href="http://yoursite.com/2017/12/25/ONOS%E4%B8%AD%E5%9F%BA%E4%BA%8EgRPC%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2017/12/25/ONOS中基于gRPC应用的实现/</id>
    <published>2017-12-25T03:15:04.000Z</published>
    <updated>2018-01-31T13:19:00.078Z</updated>
    
    <content type="html"><![CDATA[<p>gRPC是谷歌开源的一个高性能RPC框架，支持多种语言。由于ONOS是运行在基于OSGi框架的karaf容器中，而当前官方提供的gRPC包没有OSGi化，因此若要在ONOS中实现基于gRPC的应用，需要考虑gRPC依赖的OSGi化问题。</p>
<a id="more"></a>
<h1 id="1-gRPC依赖的OSGi化"><a href="#1-gRPC依赖的OSGi化" class="headerlink" title="1. gRPC依赖的OSGi化"></a>1. gRPC依赖的OSGi化</h1><p>默认情况下，OSGi框架下各个bundle是相互隔离的，不同bundle中的包不能直接引用，而依赖包的OSGi化，就是使该依赖以bundle的方式注册到OSGi框架里面并Export一些特定的package，当该bundle处于激活状态时，其它的bundle就能直接引用该bundle中的类，实现bundle的复用。</p>
<p>要对一个jar包OSGi化，一般有两种方式：</p>
<ol>
<li>解压jar包，然后编辑jar包内的META-INF/MANIFEST.MF文件，配置Bundle-Name，Bundle-SymbolicName，Bundle-Version，Export-Package，Import-Package等属性，完成后重新生成jar包。</li>
<li>使用<a href="http://felix.apache.org/documentation/subprojects/apache-felix-maven-bundle-plugin-bnd.html" target="_blank" rel="external">maven-bundle-plugin</a>插件完成jar包的OSGi化。</li>
</ol>
<p>对于运行在<a href="https://karaf.apache.org/" target="_blank" rel="external">Karaf</a>容器中的应用，可以使用<a href="http://karaf.apache.org/manual/latest-3.0.x/#_wrap_deployer" target="_blank" rel="external">wrap deployer</a>来部署一个没有OSGi化的jar包。Wrap deployer会扫描jar包并自动配置jar包内的MANIFEST.MF文件，从而完成一个jar包的OSGi化。例如可以在feature.xml中添加如下配置来使用wrap deployer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bundle&gt;wrap:mvn:io.grpc/grpc-netty/$&#123;grpc.version&#125;$Bundle-SymbolicName=io.grpc.grpc-netty&amp;amp;Bundle-Version=$&#123;grpc.package.version&#125;&lt;/bundle&gt;</div></pre></td></tr></table></figure>
<p>部署该bundle后，可以使用<code>bundle:headers id</code>查看bundle中的OSGi header信息，也就是META-INF/MANIFEST.MF中配置的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">onos&gt; bundle:headers 175</div><div class="line"></div><div class="line">io.grpc.grpc-netty (175)</div><div class="line">------------------------</div><div class="line">Built-JDK = 1.8.0_131</div><div class="line">Implementation-Title = grpc-netty</div><div class="line">Source-Compatibility = 1.6</div><div class="line">Implementation-Version = 1.3.1</div><div class="line">Created-By = 1.8.0_131 (Oracle Corporation)</div><div class="line">Manifest-Version = 1.0</div><div class="line">Bnd-LastModified = 1517389071599</div><div class="line">Generated-By-Ops4j-Pax-From = wrap:mvn:io.grpc/grpc-netty/1.3.1$Bundle-SymbolicName=io.grpc.grpc-netty&amp;Bundle-Version=1.3.1</div><div class="line">Built-By = root</div><div class="line">Target-Compatibility = 1.6</div><div class="line">Tool = Bnd-2.3.0.201405100607</div><div class="line"></div><div class="line">Bundle-ManifestVersion = 2</div><div class="line">Bundle-SymbolicName = io.grpc.grpc-netty</div><div class="line">Bundle-Version = 1.3.1</div><div class="line">Bundle-Name = io.grpc.grpc-netty</div><div class="line"></div><div class="line">Require-Capability = </div><div class="line">	osgi.ee;filter:=(&amp;(osgi.ee=JavaSE)(version=1.6))</div><div class="line"></div><div class="line">Export-Package = </div><div class="line">	io.grpc.netty;</div><div class="line">		uses:=&quot;io.grpc,</div><div class="line">			io.grpc.internal,</div><div class="line">			io.netty.buffer,</div><div class="line">			io.netty.channel,</div><div class="line">			io.netty.handler.codec.http2,</div><div class="line">			io.netty.handler.ssl,</div><div class="line">			io.netty.util,</div><div class="line">			javax.annotation&quot;</div><div class="line">Import-Package = </div><div class="line">	com.google.common.base;resolution:=optional,</div><div class="line">	com.google.common.io;resolution:=optional,</div><div class="line">	io.grpc;resolution:=optional,</div><div class="line">	io.grpc.internal;resolution:=optional,</div><div class="line">	io.netty.bootstrap;resolution:=optional,</div><div class="line">	io.netty.buffer;resolution:=optional,</div><div class="line">	io.netty.channel;resolution:=optional,</div><div class="line">	io.netty.channel.nio;resolution:=optional,</div><div class="line">	io.netty.channel.socket.nio;resolution:=optional,</div><div class="line">	io.netty.handler.codec;resolution:=optional,</div><div class="line">	io.netty.handler.codec.http;resolution:=optional,</div><div class="line">	io.netty.handler.codec.http2;resolution:=optional,</div><div class="line">	io.netty.handler.codec.http2.internal.hpack;resolution:=optional,</div><div class="line">	io.netty.handler.logging;resolution:=optional,</div><div class="line">	io.netty.handler.proxy;resolution:=optional,</div><div class="line">	io.netty.handler.ssl;resolution:=optional,</div><div class="line">	io.netty.util;resolution:=optional,</div><div class="line">	io.netty.util.concurrent;resolution:=optional,</div><div class="line">	io.netty.util.internal;resolution:=optional,</div><div class="line">	io.netty.util.internal.logging;resolution:=optional,</div><div class="line">	javax.annotation;resolution:=optional,</div><div class="line">	javax.net.ssl;resolution:=optional</div></pre></td></tr></table></figure>
<p>其中，<strong>resolution:=optional</strong>表示解析过程中对应的package不是必须的，即当一个bundle无法import到这个package时，该bundle也可以安装并激活，这可以加速bundle的部署，这也是wrap deployer默认的设置方式。但需要注意的是，当我们使用该bundle过程中需要加载使用了该package的类时，就会产生类加载的异常，所以可以使用<strong>Import-Package</strong>显示设置需要import的package：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bundle&gt;wrap:mvn:io.grpc/grpc-netty/$&#123;grpc.version&#125;$Bundle-SymbolicName=io.grpc.grpc-netty&amp;amp;Bundle-Version=$&#123;grpc.package.version&#125;&amp;amp;Import-Package=!io.netty.handler.proxy,*&lt;/bundle&gt;</div></pre></td></tr></table></figure></p>
<p>同样，可以使用<code>bundle:headers id</code>查看该bundle的OSGi header信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">onos&gt; bundle:headers 175</div><div class="line"></div><div class="line">io.grpc.grpc-netty (175)</div><div class="line">------------------------</div><div class="line">Built-JDK = 1.8.0_131</div><div class="line">Implementation-Title = grpc-netty</div><div class="line">Source-Compatibility = 1.6</div><div class="line">Implementation-Version = 1.3.1</div><div class="line">Created-By = 1.8.0_131 (Oracle Corporation)</div><div class="line">Manifest-Version = 1.0</div><div class="line">Bnd-LastModified = 1517399352696</div><div class="line">Generated-By-Ops4j-Pax-From = wrap:mvn:io.grpc/grpc-netty/1.3.1$Bundle-SymbolicName=io.grpc.grpc-netty&amp;Bundle-Version=1.3.1&amp;Import-Package=!i</div><div class="line">o.netty.handler.proxy,*Built-By = root</div><div class="line">Target-Compatibility = 1.6</div><div class="line">Tool = Bnd-2.3.0.201405100607</div><div class="line"></div><div class="line">Bundle-ManifestVersion = 2</div><div class="line">Bundle-SymbolicName = io.grpc.grpc-netty</div><div class="line">Bundle-Version = 1.3.1</div><div class="line">Bundle-Name = io.grpc.grpc-netty</div><div class="line"></div><div class="line">Require-Capability = </div><div class="line">	osgi.ee;filter:=(&amp;(osgi.ee=JavaSE)(version=1.6))</div><div class="line"></div><div class="line">Export-Package = </div><div class="line">	io.grpc.netty;</div><div class="line">		uses:=&quot;io.grpc,</div><div class="line">			io.grpc.internal,</div><div class="line">			io.netty.buffer,</div><div class="line">			io.netty.channel,</div><div class="line">			io.netty.handler.codec.http2,</div><div class="line">			io.netty.handler.ssl,</div><div class="line">			io.netty.util,</div><div class="line">			javax.annotation&quot;</div><div class="line">Import-Package = </div><div class="line">	com.google.common.base,</div><div class="line">	com.google.common.io,</div><div class="line">	io.grpc,</div><div class="line">	io.grpc.internal,</div><div class="line">	io.netty.bootstrap,</div><div class="line">	io.netty.buffer,</div><div class="line">	io.netty.channel,</div><div class="line">	io.netty.channel.nio,</div><div class="line">	io.netty.channel.socket.nio,</div><div class="line">	io.netty.handler.codec,</div><div class="line">	io.netty.handler.codec.http,</div><div class="line">	io.netty.handler.codec.http2,</div><div class="line">	io.netty.handler.codec.http2.internal.hpack,</div><div class="line">	io.netty.handler.logging,</div><div class="line">	io.netty.handler.ssl,</div><div class="line">	io.netty.util,</div><div class="line">	io.netty.util.concurrent,</div><div class="line">	io.netty.util.internal,</div><div class="line">	io.netty.util.internal.logging,</div><div class="line">	javax.annotation,</div><div class="line">	javax.net.ssl</div></pre></td></tr></table></figure></p>
<p>可以发现，io.netty.handler.proxy包已经不在Import-Package列表中，而其它的package都是在resolve该bundle过程中必须的。</p>
<p>然而，由于grpc中的grpc-core和grpc-context两个组件包含相同的包名（io.grpc），而OSGi是根据包名来查找并加载类的，这会导致其中一个包下的类无法加载，从而产生<code>NoClassDefFoundError</code>的错误，这就是OSGi中的 <a href="https://stackoverflow.com/questions/14042981/how-to-import-same-package-from-different-osgi-bundles" target="_blank" rel="external"><strong>split package</strong></a>问题。</p>
<p>解决思路就是重构包含相同包名的package并打包生成一个新的package，在这里可以使用maven-bundle-plugin插件的<strong>Export-Package</strong>功能，使用<strong>Export-Package</strong>后，对应的类也会拷贝到jar包中，这样就可以将相同包名中的类进行合并：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.felix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-bundle-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">instructions</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">Export-Package</span>&gt;</span></div><div class="line">                org.onosproject.grpc.demo,</div><div class="line">                io.grpc;version="$&#123;grpc.package.version&#125;",</div><div class="line">                io.grpc.inprocess;version="$&#123;grpc.package.version&#125;",</div><div class="line">                io.grpc.internal;version="$&#123;grpc.package.version&#125;",</div><div class="line">                io.grpc.util;version="$&#123;grpc.package.version&#125;"</div><div class="line">            <span class="tag">&lt;/<span class="name">Export-Package</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">Import-Package</span>&gt;</span>!com.google.errorprone.annotations,*<span class="tag">&lt;/<span class="name">Import-Package</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">instructions</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>另外，由于ONOS中使用了gRPC服务，因此ONOS也对gRPC包做了OSGi化处理，ONOS使用buck编译，gRPC的OSGi化参考：<a href="https://github.com/opennetworkinglab/onos/blob/master/incubator/grpc-dependencies/BUCK" target="_blank" rel="external"><strong>onos/incubator/grpc-dependencies/BUCK</strong></a>。默认情况下，ONOS没有激活gRPC依赖对应的bundle，因此若应用中需要使用gRPC服务，可以先激活ONOS中的应用：<a href="https://github.com/opennetworkinglab/onos/tree/master/protocols/grpc" target="_blank" rel="external"><strong>org.onosproject.protocols.grpc</strong></a>，这样gRPC依赖对应的bundle也将处于激活状态，然后你在自己的应用中就不用考虑gRPC依赖的OSGi化问题了。</p>
<h1 id="2-实现基于gRPC的应用"><a href="#2-实现基于gRPC的应用" class="headerlink" title="2. 实现基于gRPC的应用"></a>2. 实现基于gRPC的应用</h1><p>由于官方文档关于Hello World介绍已经很清楚了，本文还是以实现Hello World为例，介绍实现gRPC应用需要注意的问题。</p>
<ol>
<li><p>导入gRPC依赖和相关插件</p>
<p> 首先导入的gRPC依赖要和ONOS中的gRPC bundle的版本相同，另外，使用<code>build-helper-maven-plugin</code>插件添加<code>${project.build.directory}/generated-sources/protobuf/</code>目录下由.proto文件生成的源码，同时开启maven-src-plugin插件的类扫描功能，使得该插件生成scr描述信息时能够找到<code>${project.build.directory}/generated-sources/protobuf/</code>中生成的类，详细参考：<a href="https://github.com/baymaxhuang/onos-app-grpc-demo/blob/master/pom.xml" target="_blank" rel="external"><strong>pom.xml</strong></a></p>
</li>
<li><p>构建gRPC Server<br> 官方使用<code>ServerBuilder</code>构建<code>HelloWorldServer</code>，这在Karaf容器中会产生如下的异常：</p>
<p>  <strong>Caused by: io.grpc.ManagedChannelProvider$ProviderNotFoundException: No functional channel service provider found. Try adding a dependency on the grpc-okhttp or grpc-netty artifact</strong></p>
<p> 这是由于OSGi框架下不同的bundle使用的类加载器是不同的，gRPC中的这部分代码没有考虑OSGi中的类加载器的特殊性问题，解决办法是使用<code>NettyServerBuilder</code>构建一个Server：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        server = NettyServerBuilder.forPort(port)</div><div class="line">                .addService(<span class="keyword">new</span> GreeterImpl())</div><div class="line">                .build()</div><div class="line">                .start();</div><div class="line"></div><div class="line">        log.info(<span class="string">"Server started, listening on "</span> + port);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>详细代码参考：<a href="https://github.com/baymaxhuang/onos-app-grpc-demo" target="_blank" rel="external"><strong>gRPC demo</strong></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gRPC是谷歌开源的一个高性能RPC框架，支持多种语言。由于ONOS是运行在基于OSGi框架的karaf容器中，而当前官方提供的gRPC包没有OSGi化，因此若要在ONOS中实现基于gRPC的应用，需要考虑gRPC依赖的OSGi化问题。&lt;/p&gt;
    
    </summary>
    
      <category term="ONOS" scheme="http://yoursite.com/categories/ONOS/"/>
    
    
      <category term="ONOS" scheme="http://yoursite.com/tags/ONOS/"/>
    
      <category term="gRPC" scheme="http://yoursite.com/tags/gRPC/"/>
    
      <category term="OSGi" scheme="http://yoursite.com/tags/OSGi/"/>
    
  </entry>
  
  <entry>
    <title>Atomix源码分析：Raft Client的实现和与Server的交互</title>
    <link href="http://yoursite.com/2017/11/13/Atomix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9ARaft%20Client%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%B8%8EServer%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
    <id>http://yoursite.com/2017/11/13/Atomix源码分析：Raft Client的实现和与Server的交互/</id>
    <published>2017-11-13T13:16:50.000Z</published>
    <updated>2017-12-05T01:47:59.300Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/atomix/atomix" target="_blank" rel="external">Atomix</a>是一个基于Raft协议的分布式协同框架，是ONOS分布式集群和分布式原语实现的基础，Atomix提供集群的管理，通信，领导选择，Key-Value存储，以及数据分片等功能。从Atomix 2.0开始，raft协议的实现<a href="https://github.com/atomix/copycat" target="_blank" rel="external">Copycat</a>已经集成到Atomix了，下面将结合Atomix 2.0对Atomix源码进行分析，从而深入理解Raft协议的原理和Atomix的工作机制。（更新中~）</p>
<a id="more"></a>
<p>Atomix里的Raft实现主要包括raft client和raft server，raft server就是Raft里面实现数据一致性同步的节点，Raft里面的Leader，Candidate，Follower身份的确立和转换都是围绕raft server展开的,raft client通过raft session 与Raft状态机集群交互，从而完成状态机的查询，修改等操作。</p>
<p><em>注：Atomix 2.x在tests模块下新增了一个Raft测试文件<a href="https://github.com/atomix/atomix/blob/master/tests/src/main/java/io/atomix/protocols/raft/RaftFuzzTest.java" target="_blank" rel="external">RaftFuzzTest.java</a>。这个文件包含了完整的raft client和raft server的建立过程，阅读这个文件的源码对了解和学习Atomix很有帮助！</em></p>
<h1 id="1-Raft-client的实现"><a href="#1-Raft-client的实现" class="headerlink" title="1. Raft client的实现"></a>1. Raft client的实现</h1><p>Raft client的实现主要包括RaftClient，RaftProxy，RaftSession，包括Client与Server连接的建立，会话的管理，以及提交操作等功能。</p>
<h2 id="1-1-创建RaftClient"><a href="#1-1-创建RaftClient" class="headerlink" title="1.1 创建RaftClient"></a>1.1 创建RaftClient</h2><p><code>RaftClient</code>提供了与Raft集群建立连接的接口，<code>DefaultRaftClient</code>是<code>RaftClient</code>的实现类，可以使用构造器创建<code>RaftClient</code>，<code>DefaultRaftClient</code>的类图如下所示：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/RaftClient-3.png" alt="image"></p>
<p>在Atomix工程里面的<code>RaftFuzzTest</code>里有创建RaftClient的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RaftClient client = RaftClient.newBuilder()</div><div class="line">        .withMemberId(memberId) <span class="comment">//1</span></div><div class="line">        .withProtocol(protocol) <span class="comment">//2</span></div><div class="line">        .build();</div><div class="line">        </div><div class="line">client.connect(members.stream().map(RaftMember::memberId).collect(Collectors.toList())).join();</div></pre></td></tr></table></figure>
<p>其中，方法1设置该RaftClient的ID，一般用本机的IP地址表示，而方法2设置client与server的通信协议，该协议对象需要实现<code>RaftClientProtocol</code>接口。</p>
<p>创建好RaftClient后，使用RaftClient.connect与Raft cluster建立连接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* Connects the client to Raft cluster via the provided server addresses.</div><div class="line">* &lt;p&gt;</div><div class="line">* The client will connect to servers in the cluster according to the pattern specified by the configured</div><div class="line">* &#123;@link CommunicationStrategy&#125;.</div><div class="line">*</div><div class="line">* @param members A set of server addresses to which to connect.</div><div class="line">* @return A completable future to be completed once the client is registered.</div><div class="line">*/</div><div class="line">CompletableFuture&lt;RaftClient&gt; connect(Collection&lt;MemberId&gt; members);</div></pre></td></tr></table></figure>
<p>由上面的注释可知该该raft client与raft cluster的哪一个成员建立连接，是根据<code>CommunicationStrategy</code>类进行配置的，而配置这<code>CommunicationStrategy</code>由<code>RaftProxy</code>来完成的。</p>
<p>PS: 注意这里虽然说是建立连接，但也只是做一些建立连接的初始化工作，正真的建立（如发送建立会话的请求）在<code>RaftProxy</code>创建完成后进行的。</p>
<h2 id="1-2-创建RaftProxy"><a href="#1-2-创建RaftProxy" class="headerlink" title="1.2 创建RaftProxy"></a>1.2 创建RaftProxy</h2><p><code>RaftProxy</code>提供了提交特定操作到raft cluster状态机的接口，主要包括<code>invoke</code>方法和<code>addEventListener</code>方法，<code>RaftFuzzTest</code>中给了<code>RaftProxy</code>的创建示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Creates a test session.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> RaftProxy <span class="title">createProxy</span><span class="params">(RaftClient client, ReadConsistency consistency)</span> </span>&#123; </div><div class="line"><span class="keyword">return</span> client.newProxyBuilder() <span class="comment">//1</span></div><div class="line">    .withName(<span class="string">"test"</span>) <span class="comment">//2</span></div><div class="line">    .withServiceType(<span class="string">"test"</span>)</div><div class="line">    .withReadConsistency(consistency) <span class="comment">//3</span></div><div class="line">    .withCommunicationStrategy(COMMUNICATION_STRATEGY) <span class="comment">//4</span></div><div class="line">    .build() <span class="comment">//5</span></div><div class="line">    .open()</div><div class="line">    .join();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码方法1返回一个新的RaftProxy.Builder从而开始建立会话连接；方法2是设置该会话的名称；方法3设置状态机查询的一致性等级，有线性一致性，顺序一致性等，<strong>Raft协议中线性一致性的查询最终必须由Leader来处理</strong>；而方法4则设置该会话与Raft cluster的通信策略，可以指定该会话直接和Leader建立，也可让该会话随机和cluster中的某一个节点建立。更多的细节原理可以阅读<code>ReadConsistency</code>和<code>CommunicationStrategy</code>的文档注释。上面的代码将为一个raft client创建一个会话连接，可以重复上述步骤为该client建立多个到raft cluster的会话连接。需要注意的是，方法1中返回的RaftProxy.Builder是在DefaultRaftClient内实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Default Raft session builder.</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionBuilder</span> <span class="keyword">extends</span> <span class="title">RaftProxy</span>.<span class="title">Builder</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> RaftProxy <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// Create a client builder that uses the session manager to open a session.</span></div><div class="line">  RaftProxyClient.Builder clientBuilder = <span class="keyword">new</span> RaftProxyClient.Builder() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;RaftProxyClient&gt; <span class="title">buildAsync</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> sessionManager.openSession(name, serviceType, readConsistency, communicationStrategy, timeout);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过注释可知，该Builder会建立一个会话连接，这是通过该Builder实现<code>buildAsync</code>方法并在<code>buildAsync</code>内部调用<code>RaftProxyManager</code>的<code>openSession</code>方法实现的,<code>buildAsync</code>最终由方法5调用。</p>
<h2 id="1-3-创建会话连接"><a href="#1-3-创建会话连接" class="headerlink" title="1.3 创建会话连接"></a>1.3 创建会话连接</h2><p>Raft client和server所有会话的创建和管理由<code>RaftProxyManager</code>类实现。<code>RaftProxyManager</code>的构造函数如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RaftProxyManager</span><span class="params">(String clientId, MemberId memberId, RaftClientProtocol protocol, MemberSelectorManager selectorManager, ScheduledExecutorService threadPoolExecutor)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.clientId = checkNotNull(clientId, <span class="string">"clientId cannot be null"</span>);</div><div class="line"><span class="keyword">this</span>.memberId = checkNotNull(memberId, <span class="string">"memberId cannot be null"</span>);</div><div class="line"><span class="keyword">this</span>.protocol = checkNotNull(protocol, <span class="string">"protocol cannot be null"</span>);</div><div class="line"><span class="keyword">this</span>.selectorManager = checkNotNull(selectorManager, <span class="string">"selectorManager cannot be null"</span>);</div><div class="line"><span class="keyword">this</span>.log = ContextualLoggerFactory.getLogger(getClass(), LoggerContext.builder(RaftClient.class)</div><div class="line">    .addValue(clientId)</div><div class="line">    .build());</div><div class="line"></div><div class="line"><span class="keyword">this</span>.connection = <span class="keyword">new</span> RaftProxyConnection(</div><div class="line">    protocol,</div><div class="line">    selectorManager.createSelector(CommunicationStrategy.ANY),</div><div class="line">    <span class="keyword">new</span> ThreadPoolContext(threadPoolExecutor),</div><div class="line">    LoggerContext.builder(RaftClient.class)</div><div class="line">        .addValue(clientId)</div><div class="line">        .build());</div><div class="line"><span class="keyword">this</span>.threadPoolExecutor = checkNotNull(threadPoolExecutor, <span class="string">"threadPoolExecutor cannot be null"</span>);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意这里面构造了一个<code>RaftProxyConnection</code>对象，建立会话的open-session消息以及保持该会话连接的keep-alive消息的发送和接收都是由该对象完成的。传入的参数<code>selectorManager.createSelector(CommunicationStrategy.ANY</code>表示该connection是随机和cluster中的某一个成员建立的，后面的keep-alive请求也都会持续发往该成员节点并由该节点处理。<strong>笔者阅读了Raft server实现的相关代码，发现raft follower角色的成员也不直接处理open-session或keep-alive请求，而是将这个请求forward给leader处理，具体的逻辑可以参考<code>RaftRole</code>接口及其类的实现。</strong>需要注意的，client session信息都是以复制状态机的形式保存的，也就是说raft cluster中的每一个节点都保存有该session的信息，另外当leader处理一个open-session或keep-alive请求时，也会先更新follower的状态机信息（主要是该会话的时间戳），然后提交该更新到本地状态机。</p>
<p><code>RaftProxyManager</code>类里的<code>openSession</code>方法调用<code>RaftProxyConnection</code>类的<code>openSession</code>方法发送一个open-session请求，返回的response结果中包含该session的sessionId，timeout等信息，然后使用<code>keepAliveSessions</code>方法发送该会话的keep-alive消息。</p>
<p>在<code>RaftProxyManager</code>类里面，keep-alive的发送和调度分别是由<code>keepAliveSessions(long timeout)</code>和<code>scheduleKeepAlive(long timeout, long delta)</code>方法完成的。注意这个timeout的值是根据<code>OpenSessionResponse</code>获得的，在<code>LeaderRole</code>中可以看到<code>OpenSessionResponse</code>的构造逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;OpenSessionResponse&gt; <span class="title">onOpenSession</span><span class="params">(OpenSessionRequest request)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">long</span> term = raft.getTerm();</div><div class="line"><span class="keyword">final</span> <span class="keyword">long</span> timestamp = System.currentTimeMillis();</div><div class="line"></div><div class="line"><span class="comment">// If the client submitted a session timeout, use the client's timeout, otherwise use the configured</span></div><div class="line"><span class="comment">// default server session timeout.</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">long</span> timeout;</div><div class="line"><span class="keyword">if</span> (request.timeout() != <span class="number">0</span>) &#123;</div><div class="line">  timeout = request.timeout();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  timeout = raft.getSessionTimeout().toMillis();</div><div class="line">&#125;</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>在使用<code>RaftProxy.Builder</code>构造<code>RaftProxy</code>时可以设置该session的timeout，如果没有设定，timeout默认为0，那么Leader也将通过request-response返回一个timeout，这个timeout在<code>RaftContext</code>类中被默认设置为5000ms。</p>
<p>另外<code>scheduleKeepAlive(long timeout, long delta)</code>方法中的<code>delta</code>参数表示从发送一个keep-alive请求到接收到该请求响应的时间间隔，keep-alive循环调度的方法实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line">* Schedules a keep-alive request.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleKeepAlive</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">long</span> delta)</span> </span>&#123;</div><div class="line">ScheduledFuture&lt;?&gt; keepAliveFuture = keepAliveFutures.remove(timeout);</div><div class="line"><span class="keyword">if</span> (keepAliveFuture != <span class="keyword">null</span>) &#123;</div><div class="line">  keepAliveFuture.cancel(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Schedule the keep alive for 3/4 the timeout minus the delta from the last keep-alive request.</span></div><div class="line">keepAliveFutures.put(timeout, threadPoolExecutor.schedule(() -&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (open.get()) &#123;</div><div class="line">    keepAliveSessions(timeout);</div><div class="line">  &#125;</div><div class="line">&#125;, Math.max(Math.max((<span class="keyword">long</span>)(timeout * .<span class="number">75</span>) - delta, timeout - <span class="number">2500</span> - delta), <span class="number">0</span>), TimeUnit.MILLISECONDS));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的delta表示从发送keep-alive请求到获得该请求响应的时间间隔，一般该时间很短（2~4ms），因此若timeout设置成6000ms，那么keep-alive消息的发送间隔为4500ms左右。</p>
<h1 id="2-Raft-client和raft-server的交互"><a href="#2-Raft-client和raft-server的交互" class="headerlink" title="2. Raft client和raft server的交互"></a>2. Raft client和raft server的交互</h1><h2 id="2-1-Raft-client和raft-server间消息的发送和回传"><a href="#2-1-Raft-client和raft-server间消息的发送和回传" class="headerlink" title="2.1 Raft client和raft server间消息的发送和回传"></a>2.1 Raft client和raft server间消息的发送和回传</h2><p>由于Atomix中使用了很多函数式编程以及回调处理，很多的代码调动关系不是很直观，下面将以<code>RaftFuzzTest</code>的实现为例介绍Keep-Alive消息的发送和处理流程。</p>
<ol>
<li><p>首先需要了解的是<code>RaftFuzzTest</code>中使用的<code>RaftClientProtocol</code>和<code>RaftServerProtocol</code>都是基于<code>MessagingService</code>消息处理接口实现的。该消息处理接口会区分每一种消息的类型，同时也需要给不同的消息类型注册不同的处理方法，当收到一种特定类型的消息时，就会回调对应的处理方法。</p>
</li>
<li><p>如前面所述，将使用<code>RaftProxyConnection</code>类的<code>keepAlive</code>方法开始发送keep-alive请求：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Sends a keep alive request to the given node.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> request the request to send</div><div class="line">* <span class="doctag">@return</span> a future to be completed with the response</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;KeepAliveResponse&gt; <span class="title">keepAlive</span><span class="params">(KeepAliveRequest request)</span> </span>&#123;</div><div class="line">CompletableFuture&lt;KeepAliveResponse&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</div><div class="line"><span class="keyword">if</span> (context.isCurrentContext()) &#123;</div><div class="line">    sendRequest(request, protocol::keepAlive, next(), future);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    context.execute(() -&gt; sendRequest(request, protocol::keepAlive, next(), future));</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> future;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这里的<code>protocol</code>是一个实现了<code>RaftClientProtocol</code>接口对象，负责消息的发送，该对象在创建<code>RaftClient</code>时注册进来的。而<code>next()</code>则返回接收该request请求的目的成员ID，然后<code>sendRequest</code>将调用<code>RaftClientProtocol</code>的<code>keepAlive</code>方法发送该keep-alive请求，<code>RaftFuzzTest</code>中使用的<code>RaftClientProtocol</code>接口是在<code>RaftClientMessagingProtocol</code>类中实现：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;KeepAliveResponse&gt; <span class="title">keepAlive</span><span class="params">(MemberId memberId, KeepAliveRequest request)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sendAndReceive(memberId, <span class="string">"keep-alive"</span>, request);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> &lt;T, U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">sendAndReceive</span><span class="params">(MemberId memberId, String type, T request)</span> </span>&#123;</div><div class="line">    Endpoint endpoint = endpoint(memberId);</div><div class="line">    <span class="keyword">if</span> (endpoint == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> Futures.exceptionalFuture(<span class="keyword">new</span> ConnectException());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> messagingService.sendAndReceive(endpoint, type, serializer.encode(request))</div><div class="line">        .thenApply(serializer::decode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>虽然上面的回调直接返回了处理后的结果，那么这个请求在实际中是怎么处理和返回的呢？事实上，上面的<code>sendAndReceive(memberId, &quot;keep-alive&quot;, request)</code>方法使用了一个很重要的参数，即这个请求的消息类型是：”keep-alive”，而raft server节点会根据请求的类型调用对应的处理方法。<code>RaftServerProtocol</code>接口中有一个注册处理keep-alive消息的handler的方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Registers a keep alive request callback.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> handler the open session request handler to register</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerKeepAliveHandler</span><span class="params">(Function&lt;KeepAliveRequest, CompletableFuture&lt;KeepAliveResponse&gt;&gt; handler)</span></span>;</div></pre></td></tr></table></figure>
<p> <code>RaftFuzzTest</code>使用的<code>RaftServerMessagingProtocol</code>是一个实现了<code>RaftServerProtocol</code>接口的类，在这个类里面，注册处理keep-alive消息的Handler的方法实现如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerKeepAliveHandler</span><span class="params">(Function&lt;KeepAliveRequest, CompletableFuture&lt;KeepAliveResponse&gt;&gt; handler)</span> </span>&#123;</div><div class="line">    registerHandler(<span class="string">"keep-alive"</span>, handler);</div><div class="line">&#125;</div><div class="line"><span class="keyword">protected</span> &lt;T, U&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String type, Function&lt;T, CompletableFuture&lt;U&gt;&gt; handler)</span> </span>&#123;</div><div class="line">messagingService.registerHandler(type, (e, p) -&gt; &#123;</div><div class="line">  CompletableFuture&lt;<span class="keyword">byte</span>[]&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</div><div class="line">  handler.apply(serializer.decode(p)).whenComplete((result, error) -&gt; &#123; <span class="comment">//1</span></div><div class="line">    <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</div><div class="line">      future.complete(serializer.encode(result)); <span class="comment">//2</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      future.completeExceptionally(error);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> future; <span class="comment">//3</span></div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 由此可以看出，一个特定类型消息的处理方法最终会注册到<code>messagingService</code>里面，方法1调用了Handler处理方法的，而方法2则等待处理结果的返回，方法3则返回一个异步执行的结构。因此当<code>MessagingService</code>收到一个特定类型的消息时，就会调用已注册的对应该消息的处理方法，从而完成消息的处理，<code>MessagingService</code>会回传该Handler返回的结果。</p>
</li>
<li><p>上面处理keep-alive请求的Handler的注册的过程是在<code>RaftContext</code>类里实现的，这也是一个非常重要的类，前面也有提及，raft状态机状态的管理就是通过这个类实现的。注册Handler的部分代码如下所示：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line">* Registers server handlers on the configured protocol.</div><div class="line">*/</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerHandlers</span><span class="params">(RaftServerProtocol protocol)</span> </span>&#123;</div><div class="line">     protocol.registerOpenSessionHandler(request -&gt; runOnContext(() -&gt; role.onOpenSession(request)));</div><div class="line">     protocol.registerCloseSessionHandler(request -&gt; runOnContext(() -&gt; role.onCloseSession(request)));</div><div class="line">     protocol.registerKeepAliveHandler(request -&gt; runOnContext(() -&gt; role.onKeepAlive(request)));</div><div class="line"> ......</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> 因此，当raft server收到一个“keep-alive”类型的请求时，就会调用<code>role.onKeepAlive(request))</code>方法，并返回一个处理后的结果，即返回一个<code>CompletableFuture&lt;KeepAliveResponse&gt;&gt;</code>类型的值。</p>
<p> 由上面的分析可知，Atomix里面消息的处理流程的核心思想就是注册和回调，同时使用<code>CompletableFuture</code>作为异步计算的结果，提高程序的运行效率。</p>
</li>
</ol>
<h2 id="2-2-Client对状态机的操作"><a href="#2-2-Client对状态机的操作" class="headerlink" title="2.2 Client对状态机的操作"></a>2.2 Client对状态机的操作</h2><p>Client对状态机的操作包括写和读，分别用Command和Query来表示。Command操作会使状态机发生转移，需要通过leader写log并经过多数派的提交确认；Query操作可以根据一致性等级进行操作，若需实现线性一致性，需要leader的处理。</p>
<h3 id="2-2-1-Command操作"><a href="#2-2-1-Command操作" class="headerlink" title="2.2.1 Command操作"></a>2.2.1 Command操作</h3><p>参考：</p>
<ul>
<li><a href="http://atomix.io" target="_blank" rel="external">Atomix</a></li>
<li><a href="https://baymaxhuang.github.io/2017/02/15/ONOS-cluster%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%92%8C%E4%B8%9C%E8%A5%BF%E5%90%91%E9%80%9A%E4%BF%A1/" target="_blank" rel="external">ONOS cluster分布式数据存储和东西向通信</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/atomix/atomix&quot;&gt;Atomix&lt;/a&gt;是一个基于Raft协议的分布式协同框架，是ONOS分布式集群和分布式原语实现的基础，Atomix提供集群的管理，通信，领导选择，Key-Value存储，以及数据分片等功能。从Atomix 2.0开始，raft协议的实现&lt;a href=&quot;https://github.com/atomix/copycat&quot;&gt;Copycat&lt;/a&gt;已经集成到Atomix了，下面将结合Atomix 2.0对Atomix源码进行分析，从而深入理解Raft协议的原理和Atomix的工作机制。（更新中~）&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Atomix" scheme="http://yoursite.com/tags/Atomix/"/>
    
      <category term="分布式系统" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>使用CBench测试控制器性能及控制器性能调优总结</title>
    <link href="http://yoursite.com/2017/06/26/%E4%BD%BF%E7%94%A8CBench%E6%B5%8B%E8%AF%95%E6%8E%A7%E5%88%B6%E5%99%A8%E6%80%A7%E8%83%BD%E5%8F%8A%E6%8E%A7%E5%88%B6%E5%99%A8%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/06/26/使用CBench测试控制器性能及控制器性能调优总结/</id>
    <published>2017-06-26T03:21:40.000Z</published>
    <updated>2017-08-17T03:23:49.202Z</updated>
    
    <content type="html"><![CDATA[<p>CBench是一个基于OpenFlow协议的控制器性能测试工具，由于笔者在控制器开发过程需要测试控制器的性能，因而研究了CBench的相关代码，并做了一些开发和优化。下面是笔者使用CBench测试控制器性能及控制器性能调优总结。</p>
<a id="more"></a>
<h1 id="1-CBench原理及其使用"><a href="#1-CBench原理及其使用" class="headerlink" title="1. CBench原理及其使用"></a>1. CBench原理及其使用</h1><h2 id="1-1-CBench原理"><a href="#1-1-CBench原理" class="headerlink" title="1.1 CBench原理"></a>1.1 CBench原理</h2><p>CBench通过伪造交换机（fakeswitch）与控制器握手，每个交换机与控制器建立一个socket连接，使用<a href="http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html" target="_blank" rel="external">poll方式实现I/O多路复用</a>，整个程序是一个单线程程序。CBench可以工作在以下两种模式：</p>
<ol>
<li><p>Lantency模式</p>
<p> 每次发送一个PacketIn消息，并统计回应，不断重复这样的步骤，统计1秒（默认是1秒）内控制器响应的次数。</p>
</li>
<li><p>Throughput模式</p>
<p> 每次用PacketIn消息填满消息队列（outbuf，长度是65536），然后将该消息队列的消息由socket发往控制器，并统计回应，重复这样的步骤，统计1秒（默认是1秒）内控制器响应的次数。</p>
</li>
</ol>
<p>需要注意的是，CBench和控制器建立的是TCP连接，在通信带宽不受限的情况下，CBench在单位时间内能够发送的请求的个数，不仅和CBench自身性能有关，还和控制器的处理能力有关。当控制器处理能力受限时，TCP会自动调整<strong>接收窗口</strong>（rwnd）和<strong>拥塞控制窗口</strong>（cwnd）的大小，CBench发送请求的速率也会降低。</p>
<h2 id="1-2-CBench的使用"><a href="#1-2-CBench的使用" class="headerlink" title="1.2 CBench的使用"></a>1.2 CBench的使用</h2><p>CBench的使用也很简单，下载<a href="https://github.com/mininet/oflops" target="_blank" rel="external">源码</a>直接编译就可以了。由于这个代码比较老旧，这个project在新版本的操作系统中编译可能会出现问题（亲测在Ubuntu 14.04系统编译可以通过，但在Ubuntu 16.04中编译就有问题）。不过CBench只是这个oflops的一个子模块，因此笔者重构了CBench部分的代码，从而使得CBench可以单独编译，见：<a href="https://github.com/baymaxhuang/cbench" target="_blank" rel="external">重构后的CBench源码和使用</a>, 该版本的代码可以很容易的使用cmake和gcc编译，并用与OpenFlow控制器的测试。另外，由于笔者在控制器开发过程中需要使用其它的南向协议，因而修改了CBench的协议栈相关的代码，见：<a href="https://github.com/baymaxhuang/pof-cbench" target="_blank" rel="external">源码</a>。</p>
<h1 id="2-CBench测试控制器性能"><a href="#2-CBench测试控制器性能" class="headerlink" title="2. CBench测试控制器性能"></a>2. CBench测试控制器性能</h1><p>笔者使用的是基于Java开发的控制器，因此<strong>Java虚拟机内存的分配</strong>对控制器性能的测试影响很大。同时为了避免带宽资源的限制，CBench和控制器都在同一机器上运行。参考：</p>
<p><a href="https://wiki.onosproject.org/display/ONOS/1.10%3A+Experiment+G+-+Single-node+ONOS+Cbench" target="_blank" rel="external">Single-node ONOS Cbench</a></p>
<h1 id="3-控制器性能调优"><a href="#3-控制器性能调优" class="headerlink" title="3. 控制器性能调优"></a>3. 控制器性能调优</h1><p>笔者在要完成的是基于ONOS的POF控制器的性能测试。但在测试的过程中发现，基于ONOS的OpenFlow控制器的响应速率可以达到90w/s，而相同环境下基于ONOS的POF控制器的性能只有4w/s。于是笔者尝试使用Java程序的性能分析工具VisuaVM来分析程序的性能，关于VisualVM的使用，参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/" target="_blank" rel="external">使用 VisualVM 进行性能分析及调优</a>。</p>
<p>下面是使用VisualVM观测到在测试过程中CPU和内存的使用情况：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/cpu&amp;memory.png" alt=""></p>
<p>从图中可以发现，限制控制器性能的主要还是CPU资源，于是进一步使用VisualVM测试了关键方法的耗时：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/Java%20method%20time.png" alt=""></p>
<p>可以发现，大量CPU资源不是消耗在了与io相关的操作，而是消耗在了与io无关的object.toString方法。检查程序发现在与程序io相关的decode方法中使用了log.debug方法，而该方法虽然不会在正常模式下输出日志，但是该方法及其内部字符串拼接操作都会执行，造成大量的CPU资源浪费。下面一段简单的验证代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int x = 0;</div><div class="line">log.info(&quot;test for inf, x: &#123;&#125;&quot;, x);</div><div class="line">log.debug(&quot;test for debug, x: &#123;&#125;&quot;, test());</div><div class="line">log.info(&quot;test for x: &#123;&#125;&quot;, x);</div><div class="line">        </div><div class="line">int test() &#123;</div><div class="line">    x = x + 1;</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上日志的输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">test for inf, x: 0</div><div class="line">test for x: 1</div></pre></td></tr></table></figure>
<p>这个例子说明log.debug中的test函数也执行了，只是日志没有输出。这也提示我们<strong>使用log日志时一定要谨慎，避免使用没有必要日志输出！！！</strong></p>
<p>下面是去掉debug相关的日志方法后的关键方法耗时分析：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/pof-snapshot.png" alt=""></p>
<p>可以发现，现在CPU主要用于io相关的操作了，而测试结果也从4w/s上升到了130w/s。:)</p>
<p>另外，笔者也发现当请求或响应数据包的长度增加时，测试过程中控制器的<strong>Java虚拟机GC</strong>活动也会增加，造成测试的控制器性能下降，这在控制器测试或性能调优的过程中也是需要注意的。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>本文分析了CBench工作原理，介绍了CBench使用方法和一些需要注意的问题。另外，本文也从控制器测试的实战经验出发，介绍了Java程序的性能分析和调优方法，以飨读者。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CBench是一个基于OpenFlow协议的控制器性能测试工具，由于笔者在控制器开发过程需要测试控制器的性能，因而研究了CBench的相关代码，并做了一些开发和优化。下面是笔者使用CBench测试控制器性能及控制器性能调优总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Controller" scheme="http://yoursite.com/categories/Controller/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="CBench" scheme="http://yoursite.com/tags/CBench/"/>
    
      <category term="Controller" scheme="http://yoursite.com/tags/Controller/"/>
    
  </entry>
  
  <entry>
    <title>Kryo序列化及其在ONOS中的应用</title>
    <link href="http://yoursite.com/2017/06/14/Kryo%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%85%B6%E5%9C%A8ONOS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2017/06/14/Kryo序列化及其在ONOS中的应用/</id>
    <published>2017-06-14T13:24:58.000Z</published>
    <updated>2017-06-18T06:56:32.134Z</updated>
    
    <content type="html"><![CDATA[<p>Kryo是一个快速高效的Java序列化框架，旨在提供快速、高效和易用的API。无论文件、数据库或网络数据Kryo都可以随时完成序列化。Kryo还可以执行自动深拷贝（克隆）、浅拷贝（克隆）。这是对象到对象的直接拷贝，而不是对象-&gt;字节-&gt;对象的拷贝。</p>
<a id="more"></a>
<h1 id="1-Kryo的快速入门"><a href="#1-Kryo的快速入门" class="headerlink" title="1. Kryo的快速入门"></a>1. Kryo的快速入门</h1><p>首先，建议使用maven的方式在pom.xml中添加Kryo依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;kryo&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.0.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>然后，使用下面的方式就能完成对象的序列化了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Kryo kryo = <span class="keyword">new</span> Kryo();</div><div class="line"><span class="comment">// ...</span></div><div class="line">Output output = <span class="keyword">new</span> Output(<span class="keyword">new</span> FileOutputStream(<span class="string">"file.bin"</span>));</div><div class="line">SomeClass someObject = ...</div><div class="line">kryo.writeObject(output, someObject);</div><div class="line">output.close();</div><div class="line"><span class="comment">// ...</span></div><div class="line">Input input = <span class="keyword">new</span> Input(<span class="keyword">new</span> FileInputStream(<span class="string">"file.bin"</span>));</div><div class="line">SomeClass someObject = kryo.readObject(input, SomeClass.class);</div><div class="line">input.close();</div></pre></td></tr></table></figure>
<h1 id="2-注册要序列化的类"><a href="#2-注册要序列化的类" class="headerlink" title="2. 注册要序列化的类"></a>2. 注册要序列化的类</h1><p>当事先没有注册要序列化的类时，Kryo会自动的注册所有要使用的类，但这会增加序列化的一些overhead，例如需要在序列化时添加完整的类名称信息。而且，这种自动注册方式会使得不同程序或线程对同样的类的注册顺序不一样，从而对同样的类的产生不一样的注册ID，这样不同程序或线程对同样的类的序列化和去序列化就会发生问题。</p>
<p>可以使用 <strong>kryo.setRegistrationRequired(true)</strong> 要求显示注册要序列化的类。这样如果类没有注册，在序列化过程中就会产生java.lang.IllegalArgumentException的异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Class is not registered: kryo.test.A</div><div class="line">Note: To register this class use: kryo.register(kryo.test.A.class);</div><div class="line">	at com.esotericsoftware.kryo.Kryo.getRegistration(Kryo.java:503)</div><div class="line">	at com.esotericsoftware.kryo.Kryo.writeObject(Kryo.java:557)</div><div class="line">......</div></pre></td></tr></table></figure>
<p>使用下面的方法注册要序列化的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Kryo kryo = new Kryo();</div><div class="line">kryo.register(SomeClass.class);</div><div class="line">// ...</div><div class="line">Output output = ...</div><div class="line">SomeClass someObject = ...</div><div class="line">kryo.writeObject(output, someObject);</div></pre></td></tr></table></figure>
<p>在注册类的时候，Kryo会给每个类关联一个唯一的ID，不同的类的ID不一样，当在序列化类的对象时，Kryo只需保存这个类的ID信息，就可以识别序列化对象的类信息了。相对于保存完整的类名称信息，这种序列化方式能够提高效率。因此，不同程序或线程在对同样的对象信息序列化和去序列化时，要保证同样的类的注册ID是一样的。</p>
<p>当然，也可以指定类的注册ID信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Kryo kryo = new Kryo();</div><div class="line">kryo.register(SomeClass.class, 10);</div><div class="line">kryo.register(AnotherClass.class, 11);</div><div class="line">kryo.register(YetAnotherClass.class, 12);</div></pre></td></tr></table></figure>
<h1 id="3-序列化器（serializer）"><a href="#3-序列化器（serializer）" class="headerlink" title="3. 序列化器（serializer）"></a>3. 序列化器（serializer）</h1><p>对Java中的一些基本数据类型，如bood，short，int，char等，字符串类型String，基本数据类型的装箱类，Boolean，Short，Integer等，以及常见的集合类型，Kryo都有默认的序列化方式。参考<a href="https://github.com/EsotericSoftware/kryo#default-serializers" target="_blank" rel="external">Default serializers</a></p>
<p>用户可以在注册过程中添加指定的serializer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Kryo kryo = <span class="keyword">new</span> Kryo();</div><div class="line">kryo.register(SomeClass.class, <span class="keyword">new</span> SomeSerializer());</div><div class="line">kryo.register(AnotherClass.class, <span class="keyword">new</span> AnotherSerializer());</div></pre></td></tr></table></figure>
<h1 id="4-多线程下使用Kryo"><a href="#4-多线程下使用Kryo" class="headerlink" title="4. 多线程下使用Kryo"></a>4. 多线程下使用Kryo</h1><p>Kryo不是线程安全的，每一个线程应该有自己的Kryo，Input，和Output实例。另外，在去序列化过程中使用byte[] Input时，这个byte[]数组会被修改并在去序列化完成后返回到初始状态。因此不同的线程不能同时使用相同的byte[] Input。</p>
<h1 id="5-池化Kryo实例"><a href="#5-池化Kryo实例" class="headerlink" title="5. 池化Kryo实例"></a>5. 池化Kryo实例</h1><p>由于Kryo实例的创建和初始化的代价很高，并且不同的线程需要独立的Kryo实例。因此，多线程环境下应该考虑池化Kryo实例，从而减少Kryo实例创建和初始化的开销，提高序列化的效率。</p>
<ul>
<li><p>方法一：使用ThreadLocal建立Kryo实例：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Setup ThreadLocal of Kryo instances</div><div class="line">private static final ThreadLocal&lt;Kryo&gt; kryos = new ThreadLocal&lt;Kryo&gt;() &#123;</div><div class="line">	protected Kryo initialValue() &#123;</div><div class="line">		Kryo kryo = new Kryo();</div><div class="line">		// configure kryo instance, customize settings</div><div class="line">		return kryo;</div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// Somewhere else, use Kryo</div><div class="line">Kryo k = kryos.get();</div><div class="line">...</div></pre></td></tr></table></figure>
<p>  使用ThreadLocal创建只能被一个线程读写的变量，不同线程可以同时使用一个ThreadLocal变量的引用，但它可访问的ThreadLocal变量保存的值是相互独立的。这里将Kryo实例保存在ThreadLocal变量中，不同线程使用get方法获得一个独立的Kryo实例，这样使非线程安全的Kryo对象变得线程安全。</p>
<p>  <strong>FIXME</strong>：虽然这样做能够实现线程安全的Kryo对象，但由于每个线程获得的是与该线程相关的独立Kryo实例，因此并不能减少Kryo实例创建和初始化的开销？</p>
</li>
<li><p>方法二：使用Kryo提供的KryoPool产生Kryo实例：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import com.esotericsoftware.kryo.Kryo;</div><div class="line">import com.esotericsoftware.kryo.pool.*;</div><div class="line"></div><div class="line">KryoFactory factory = new KryoFactory() &#123;</div><div class="line">  public Kryo create () &#123;</div><div class="line">    Kryo kryo = new Kryo();</div><div class="line">    // configure kryo instance, customize settings</div><div class="line">    return kryo;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">// Build pool with SoftReferences enabled (optional)</div><div class="line">KryoPool pool = new KryoPool.Builder(factory).softReferences().build();</div><div class="line">Kryo kryo = pool.borrow();</div><div class="line">// do s.th. with kryo here, and afterwards release it</div><div class="line">pool.release(kryo);</div><div class="line"></div><div class="line">// or use a callback to work with kryo - no need to borrow/release,</div><div class="line">// that&apos;s done by `run`.</div><div class="line">String value = pool.run(new KryoCallback() &#123;</div><div class="line">  public String execute(Kryo kryo) &#123;</div><div class="line">    return kryo.readObject(input, String.class);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>  KryoPool将所有的Kryo实例保存在一个Queue中，查看Kryo源码可以发现该Queue是一个ConcurrentLinkedQueue，因此是线程安全的。同时，可以使用borrow和release方法租用和释放Kryo实例，减少Kryo实例创建和初始化的开销。</p>
</li>
</ul>
<h1 id="6-Kryo在ONOS中的应用"><a href="#6-Kryo在ONOS中的应用" class="headerlink" title="6. Kryo在ONOS中的应用"></a>6. Kryo在ONOS中的应用</h1><p>ONOS使用Kryo序列化对象，使用一个KryoNamespace类来管理类的注册，Kryo类的池化，并提供序列化方法。</p>
<p>kryonamespaces实现KryoFactory, KryoPool接口，kryonamespaces类中有最重要的两个数据属性，一个是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private List&lt;Pair&lt;Class&lt;?&gt;, Serializer&lt;?&gt;&gt;&gt; types = new ArrayList&lt;&gt;();</div></pre></td></tr></table></figure>
<p>它保存注册的序列化的类和其对应的序列化器，当我们将类注册进kryonamespace时就是在向这个List里面添加pair。</p>
<p>另一个是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private int blockHeadId = INITIAL_ID;</div></pre></td></tr></table></figure>
<p>当我们在注册需要序列化的类的时候该int类型的数据就会在原来的数据上加1。另外就是序列化实现的时候是将list类型的type改造成RegistrationBlock类之后再用list将其整块整块装进去，具体过程参考KryoNamespace.Builder。</p>
<p>kryonamespaces提供如下的序列化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Serializes given object to byte array using Kryo instance in pool.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Note: Serialized bytes must be smaller than &#123;@link #MAX_BUFFER_SIZE&#125;.</div><div class="line"> *</div><div class="line"> * @param obj Object to serialize</div><div class="line"> * @return serialized bytes</div><div class="line"> */</div><div class="line">public byte[] serialize(final Object obj) &#123;</div><div class="line">    return serialize(obj, DEFAULT_BUFFER_SIZE);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Serializes given object to byte array using Kryo instance in pool.</div><div class="line"> *</div><div class="line"> * @param obj Object to serialize</div><div class="line"> * @param bufferSize maximum size of serialized bytes</div><div class="line"> * @return serialized bytes</div><div class="line"> */</div><div class="line">public byte[] serialize(final Object obj, final int bufferSize) &#123;</div><div class="line">    Output out = new Output(bufferSize, MAX_BUFFER_SIZE);</div><div class="line">    return pool.run(kryo -&gt; &#123;</div><div class="line">        kryo.writeClassAndObject(out, obj);</div><div class="line">        out.flush();</div><div class="line">        return out.toBytes();</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，serialize最终使用kryo.writeClassAndObject方法完成对象的序列化。</p>
<p>参考：</p>
<ul>
<li><p><a href="https://github.com/EsotericSoftware/kryo" target="_blank" rel="external">https://github.com/EsotericSoftware/kryo</a></p>
</li>
<li><p><a href="http://x-rip.iteye.com/blog/1555344" target="_blank" rel="external">Kryo为什么比Hessian快</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="external">Java并发编程：深入剖析ThreadLocal</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kryo是一个快速高效的Java序列化框架，旨在提供快速、高效和易用的API。无论文件、数据库或网络数据Kryo都可以随时完成序列化。Kryo还可以执行自动深拷贝（克隆）、浅拷贝（克隆）。这是对象到对象的直接拷贝，而不是对象-&amp;gt;字节-&amp;gt;对象的拷贝。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Kryo" scheme="http://yoursite.com/tags/Kryo/"/>
    
  </entry>
  
  <entry>
    <title>ONOS cluster分布式数据存储和东西向通信</title>
    <link href="http://yoursite.com/2017/02/15/ONOS-cluster%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%92%8C%E4%B8%9C%E8%A5%BF%E5%90%91%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2017/02/15/ONOS-cluster分布式数据存储和东西向通信/</id>
    <published>2017-02-15T07:38:57.000Z</published>
    <updated>2017-12-21T12:49:39.752Z</updated>
    
    <content type="html"><![CDATA[<p>ONOS是一个分布式的控制器，为了提高数据的读写效率，采用自实现的基于In-Memory的Key-Value数据存储系统。针对实际的需要，不同的数据模型采用不同的数据一致性方法，即强一致性（strong consistency）和最终一致性（eventually consistency）。ONOS使用raft协议实现强一致性，使用anti-entropy（gossip）协议实现最终一致性。</p>
<a id="more"></a>
<h1 id="1-ONOS系统架构演进"><a href="#1-ONOS系统架构演进" class="headerlink" title="1. ONOS系统架构演进"></a>1. ONOS系统架构演进</h1><p>ONOS当前的数据采用In-Memory方式存储和同步，其架构师Madan Jampani来自Amazon，是Amazon的Dynamo的核心架构师之一，07年就在业界发表过分布式存储论文<a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="external">Dynamo</a>。另一位Jordan Halterman就是Raft协议的Java实现版CopyCat，分布式协同框架Atomix的作者。然而，最初的ONOS版本使用的是一些比较成熟的第三方的数据库存储系统。如ONOS的第一个<a href="http://www-cs-students.stanford.edu/~rlantz/papers/onos-hotsdn.pdf" target="_blank" rel="external">样机</a>使用Cassandra作为数据分布式数据存储系统，使用Zookeeper实现设备与ONOS的主从关系控制器，实现ONOS集群管理。为了提高ONOS的性能，ONOS正式发布的1.0版本采用的是embedded模式下的<a href="https://hazelcast.org/" target="_blank" rel="external">Hazelcast</a>作为基于内存的分布式存储系统，embedded模式下的Hazelcast采用peer-to-peer的方式通信，每一个ONOS instance作为一个peer，ONOS的业务数据存储在用一个JVM中，从而提高ONOS cluster的性能。</p>
<p>然而，使用第三方库的风险是不可控的，尤其在第三方库版本升级或有bug时，这对于想要实现一个搞性能，高可靠的控制器来说是不可接受的，因此，ONOS在后面的版本中使用自研的基于raft协议的分布式存储系统。<a href="https://raft.github.io/" target="_blank" rel="external">Raft协议</a>比Paxo协议简单易懂，目前已经有很多语言的实现版本，ONOS使用的是基于Java实现的CopyCat版本。但ONOS没有直接使用CopyCat，而是使用了基于raft的分布式协同框架<a href="http://atomix.io/" target="_blank" rel="external">Atomix</a>，该框架通过提供一些简单的原语接口来隐藏分布式系统中的复杂问题，如领导选择，并发控制，数据分片和复制等。</p>
<p>从ONOS系统架构演进的过程中，我们可以看出实现一个高性能，搞可靠的分布式系统架构并不容易，需要根据实际的业务特性付出很多尝试很创新。然而，利用已有的技术的方法快速实现一个original prototype也是一个很好的选择。</p>
<p>参考：</p>
<ul>
<li><p><a href="http://www.sdnlab.com/9021.html" target="_blank" rel="external">ONOS高可用性和可扩展性实现初探</a></p>
</li>
<li><p><a href="http://blog.sciencenet.cn/blog-2342751-875600.html" target="_blank" rel="external">ONOS系统架构之高可用实现方案的演进</a></p>
</li>
<li><a href="http://docs.hazelcast.org/docs/latest-development/manual/html/Consistency_and_Replication_Model.html" target="_blank" rel="external">Hazelcast Consistency and Replication Model</a></li>
</ul>
<h1 id="2-ONOS数据存储的一致性模型"><a href="#2-ONOS数据存储的一致性模型" class="headerlink" title="2. ONOS数据存储的一致性模型"></a>2. ONOS数据存储的一致性模型</h1><p>在分布式数据存储系统中，数据的一致性模型分为两类，即强一致性和最终一致性：</p>
<ul>
<li>强一致性(strong consistency)：多个进程或节点在任何时刻都能读取到相同的数据，当有节点要对数据更新时，各个节点要确认对更新的值达成一致后再更新相应的数据，ONOS使用RAFT协议实现强一致性。</li>
</ul>
<ul>
<li>最终一致性(eventual consistency)：多个进程或节点在相同的时刻可能对相同数据有不同的访问值，但经过一定时间后数据的更新会达成一致，ONOS使用事件乐观异步复制和anti-entropy(gossip)协议实现最终一致性。下面是最终一致性的实现方法：</li>
</ul>
<p><img src="http://oj37kd49l.bkt.clouddn.com/eventually%20consistency.png" alt=""></p>
<p>何时使用强一致性和弱一致性，这取决于系统对不同模型的一致性需求，同时要考虑实际一致性的可操作性。例如每个控制器都要有网络的全局拓扑信息，在很多情况下，拓扑信息是不变的，拓扑信息的变化是由于物理网络的变化，控制器只是拓扑信息的<strong>观察者</strong>，这在实现强一致性过程中需要很多代价，因此对于物理拓扑，ONOS使用最终一致性。事实上，传统的OSPF协议也是使用弱一致性快速收敛的。若控制器是数据变化的<strong>生产者</strong>，往往采用强一致性，如Intent下发，控制器到交换机的主从关系的维护。下面是ONOS中使用的一致性模型分类：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>一致性模型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Network Topology, Flow Stats</td>
<td>最终一致，低延迟读取</td>
</tr>
<tr>
<td>Flow Rules</td>
<td>乐观复制备份</td>
</tr>
<tr>
<td>Application, Intents, Resource Allocations</td>
<td>强一致性</td>
</tr>
</tbody>
</table>
<p>为了隐藏数据存储的复杂性，ONOS提供了一些分布式原语（distributed primitive）来实现数据的强一致性和最终一致性存储，使用<code>StorageService</code>服务可以创建这些原语数据结构。如<code>EventuallyConsistentMap&lt;K, V&gt;</code>用来存储一个最终一致性map，<code>EventuallyConsistentMap</code>直接在<strong>本地</strong>进行数据读写操作，有节点的map值发生更新时，ONOS会广播更新时间和更新的值，其它的节点会通过比较时间戳来更新map的值。另外，当有新节点加入或有节点的数据突然丢失时，ONOS使用anti-entropy(gossip)协议来确保数据的最终一致性。而<code>ConsistentMap&lt;K, V&gt;</code>是一个实现了强一致性的map，该map最终是通过Atomix框架的raft协议实现的。但需要注意的是，强一致性也有不同的等级，如线性一致性（linearizable consistency）, 可串化一致性（serializable consistency）, 顺序一致性（sequential consistency）。<code>ConsistentMap</code>实现的一致性模型是线性一致性地写和顺序一致性地读，也就是说，一个节点执行了写操作，那么这个写操作会立即在这个节点完成，即这个写操作对当前节点后面的读操作都是可见的（linearizable consistency）。ConsistentMap并不保证这个写操作对其它节点也立即可见，但其它节点会以相同的顺序读取到当前节点的更新（sequential consistency）。</p>
<p>需要注意的是，实现强一致性的代价是昂贵的，为了提高数据的读取效率，可以使用本地缓存<code>ConsistentMap</code>的方式来提高部分读操作（如get，containsKey等操作）的读取效率，相关代码在<code>CachingAsyncConsistentMap</code>中实现。构建<code>ConsistentMap</code>时可以使用<code>withRelaxedReadConsistency</code>方法设置使用本地缓存的方式读取map。</p>
<p>参考：</p>
<ul>
<li><p><a href="https://groups.google.com/a/onosproject.org/forum/#!search/onos$20cluster$20communication/onos-discuss/GVwEuBYL0rk/zkD9rDFHxmkJ" target="_blank" rel="external">Googlegroups: Using both RAFT and Anti-Entropy for consensus</a></p>
</li>
<li><p><a href="https://groups.google.com/a/onosproject.org/forum/#!starred/onos-discuss/tw20svjdlIY" target="_blank" rel="external">Googlegroups: Why Network Topology can be used an Eventual Consistency model in ONOS</a></p>
</li>
</ul>
<h1 id="3-ONOS集群数据分片"><a href="#3-ONOS集群数据分片" class="headerlink" title="3. ONOS集群数据分片"></a>3. ONOS集群数据分片</h1><p>为了提高数据的访问效率，ONOS数据采用分片式(partition or shard)存储，每一个partition有多个（默认是3个）member(ONOS node)， 又称为一个raft group或partition server，每个partition的多个member使用raft协议（atomix框架的copycat实现）来保证数据的一致性，ONOS使用client-server模型来实现对不同partition数据的访问。默认的，对于n个节点的集群，有n个3-node partition，具体看查看<code>ClusterManager</code>源码。每个partition的数据更新是串行的（保证一致性），不同的partition的数据可以并行更新（数据分片提高数据的访问效率），使用2PC协议实现数据跨分片更新事务。下面是数据的分片复制图示：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/data%20placement.png" alt=""></p>
<p>raft使用复制状态机的方式实现数据的一致性，可容忍少部分节点的故障失效，因此若数据分片大小为3，那么最多可容忍一个节点的失效。需要注意的是<strong>可容忍失效的节点数目与数据分片的个数有关，而与ONOS节点个数没有直接关系</strong>。</p>
<p>关于数据分片的管理和同步，可以查看<code>PartitionService</code>, <code>PartitionAdminService</code>，<code>PartitionManager</code>，<code>StoragePartition</code>，<code>StoragePartitionClient</code>，<code>StoragePartitionServer</code>等接口和类，注意：<code>StoragePartition</code>与<code>StoragePartitionClient</code>和<code>StoragePartitionServer</code>是相互引用的关系！下面是<code>PartitionManager</code>中的一段代码：</p>
<p><strong><em>ps</em>：</strong> 这一小段代码就用到了java8的几个重要特性，如lambda表达式，流式处理，方法引用等，很酷吧！:wink:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Activate</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">()</span> </span>&#123;</div><div class="line">    eventDispatcher.addSink(PartitionEvent.class, listenerRegistry);</div><div class="line">    currentClusterMetadata.set(metadataService.getClusterMetadata());</div><div class="line">    metadataService.addListener(metadataListener);</div><div class="line">    currentClusterMetadata.get()</div><div class="line">                   .getPartitions()</div><div class="line">                   .forEach(partition -&gt; partitions.put(partition.getId(), <span class="keyword">new</span> StoragePartition(partition,</div><div class="line">                           messagingService,</div><div class="line">                           clusterService,</div><div class="line">                           CatalystSerializers.getSerializer(),</div><div class="line">                           <span class="keyword">new</span> File(System.getProperty(<span class="string">"karaf.data"</span>) + <span class="string">"/partitions/"</span> + partition.getId()))));</div><div class="line"></div><div class="line">    CompletableFuture&lt;Void&gt; openFuture = CompletableFuture.allOf(partitions.values()</div><div class="line">                                                                           .stream()</div><div class="line">                                                                           .map(StoragePartition::open)</div><div class="line">                                                                           .toArray(CompletableFuture[]::<span class="keyword">new</span>));</div><div class="line">    openFuture.join();</div><div class="line">    log.info(<span class="string">"Started"</span>);</div></pre></td></tr></table></figure>
<p>可以看出，这里根据当前当前集群中已经分配好的partition来创建对应的目录文件，从而保存相关的数据信息，数据保存在karaf运行目录下的data/partitions文件夹中，查看各个各个节点中的partition目录下的文件，发现该目录下的partitionId信息与用<code>partitions -c</code>查看的信息是一致的。</p>
<p>使用<code>partitions</code>命令查看当前节点存储的分片信息，使用<code>partitions -c</code>查看当前节点以client身份访问的所有分片信息，前者返回的是<code>StoragePartitionServer</code>的信息，后者返回的是<code>StoragePartitionClient</code>的信息，二者和Atomix的框架实现有关。事实上，一个ONOS节点保存有多个分片信息，但可能不是所有分片的信息，每个ONOS节点是所有分片的client，使用client-server访问每一个分片的数据。在onos-gen-partition中可以设置分片大小，即每个分片的member成员的个数，初始分片配置信息保存在config/cluster.json中，分片的过程在<code>ClusterManager</code>类中执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">onos&gt; partitions </div><div class="line">----------------------------------------------------------</div><div class="line">Name                     Term                   Members </div><div class="line">----------------------------------------------------------</div><div class="line">1                           1      192.168.109.192:9876 </div><div class="line">                                   192.168.109.193:9876 </div><div class="line">                                   192.168.109.194:9876 *</div><div class="line">----------------------------------------------------------</div><div class="line">4                           1      192.168.109.192:9876 *</div><div class="line">                                   192.168.109.195:9876 </div><div class="line">                                   192.168.109.196:9876 </div><div class="line">----------------------------------------------------------</div><div class="line">5                           1      192.168.109.192:9876 *</div><div class="line">                                   192.168.109.193:9876 </div><div class="line">                                   192.168.109.196:9876 </div><div class="line">----------------------------------------------------------</div><div class="line">onos&gt; partitions -c</div><div class="line">-------------------------------------------------------------------</div><div class="line">Name                 SessionId     Status                   Servers</div><div class="line">-------------------------------------------------------------------</div><div class="line">1                          22     ACTIVE      192.168.109.192:9876</div><div class="line">                                              192.168.109.193:9876</div><div class="line">                                              192.168.109.194:9876</div><div class="line">-------------------------------------------------------------------</div><div class="line">2                           3     ACTIVE      192.168.109.193:9876</div><div class="line">                                              192.168.109.194:9876</div><div class="line">                                              192.168.109.195:9876</div><div class="line">-------------------------------------------------------------------</div><div class="line">3                          11     ACTIVE      192.168.109.194:9876</div><div class="line">                                              192.168.109.195:9876</div><div class="line">                                              192.168.109.196:9876</div><div class="line">-------------------------------------------------------------------</div><div class="line">4                           4     ACTIVE      192.168.109.192:9876</div><div class="line">                                              192.168.109.195:9876</div><div class="line">                                              192.168.109.196:9876</div><div class="line">-------------------------------------------------------------------</div><div class="line">5                          22     ACTIVE      192.168.109.192:9876</div><div class="line">                                              192.168.109.193:9876</div><div class="line">                                              192.168.109.196:9876</div><div class="line">-------------------------------------------------------------------</div></pre></td></tr></table></figure>
<p>其中，name表示PartitionId，term表示当前领导任期，member表示分片成员raft group），*表示当前分片成员的领导（leader）。</p>
<p>由于ONOS采用领导选举机制来同步信息，因而不用的ONOS实例间的信息交互可能是不对称的。</p>
<p><strong><em>注：</em></strong> ONOS中还有一种work partition，用来把一些task（主要和intent相关）分配到特定的节点，每一个work partition用topic来标识，使用<code>leadershipService</code>选举获得work partition的leader，具体的代码在<code>WorkPartitionManager</code>类中实现。</p>
<h1 id="4-ONOS分布式原语实现分析"><a href="#4-ONOS分布式原语实现分析" class="headerlink" title="4. ONOS分布式原语实现分析"></a>4. ONOS分布式原语实现分析</h1><p>ONOS提供多种的分布式原来实现分布式的操作和存储，如领导原则（<code>LeaderElector</code>），全局原子ID（<code>AtomicIdGenerator</code>），Key-Value（<code>ConsistentMap</code>）存储等，<code>StorageService</code>服务提供统一创建分布式原语的接口，使用构造器模式创建分布式原语。ONOS中每一个基于Atomix框架和Raft协议实现的分布式原语都对应的了一状态机实例，不同的状态机实例通过原语的名称进行区分，这些状态机实例共享存储在的数据分片集合中。下面以<code>LeaderElector</code>为例（1.11.0-SNAPSHOT），介绍分布式原语的实现和创建流程。</p>
<ol>
<li><p>LeadElector的实现分析</p>
<p> <code>LeadElector</code>是针对一个特定的topic，选举一个leader，<code>LeadElector</code>是<code>AsyncLeaderElector</code>异步执行完成后的结果（即<code>CompletableFuture.get</code>方法返回的值），ONOS中的所有的分布式原语底层都是基于<code>CompletableFuture</code>异步实现的。需要注意的是，<code>LeadElector</code>实现的选举与raft算法里面的选举规则是不一样的，通过<code>AsyncLeaderElector</code>接口的注释可以发现，Atomix是通过FIFO的方式控制对一个topic标识的资源的访问来实现领导选举的。即当使用<code>CompletableFuture&lt;Leadership&gt; run(String topic, NodeId nodeId)</code>完成一次领导选举时，就会将该nodeId加入到该topic标识的队列中，所有队列中的节点都是该topic的Candidate，而队列头部的元素就是该topic的leader。ONOS中org.onosproject.store.primitives.resources.impl包下的<code>AtomixLeaderElector</code>类是<code>AsyncLeaderElector</code>底层实现，而LeaderElector对应的状态机操作在<code>AtomixLeaderElectorService</code>类中实现。事实上，每一个基于Atomix实现的原语都有一个Atomix<strong>XXX</strong>和Atomix<strong>XXX</strong>Service的实现类。例如，<code>AtomixLeaderElector</code>类中的领导选举<code>run</code>方法的代码实现如下:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Leadership&gt; <span class="title">run</span><span class="params">(String topic, NodeId nodeId)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> proxy.&lt;Run, Leadership&gt;invoke(RUN, SERIALIZER::encode, <span class="keyword">new</span> Run(topic, nodeId), SERIALIZER::decode)</div><div class="line">            .whenComplete((r, e) -&gt; cache.invalidate(topic));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 该方法通过一个<code>RaftProxy</code>与Raft状态机进行交互，<code>RUN</code>就是这次操作的类型，代表的是一次写入操作，该状态机操作是通过<code>AtomixLeaderElectorService</code>类中的<code>run</code>方法实现的，返回的是一个<code>Leadership</code>类型的对象。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Applies an &#123;<span class="doctag">@link</span> AtomixLeaderElectorOperations.Run&#125; commit.</div><div class="line">* <span class="doctag">@param</span> commit commit entry</div><div class="line">* <span class="doctag">@return</span> topic leader. If no previous leader existed this is the node that just entered the race.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Leadership <span class="title">run</span><span class="params">(Commit&lt;? extends Run&gt; commit)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        String topic = commit.value().topic();</div><div class="line">        Leadership oldLeadership = leadership(topic);</div><div class="line">        Registration registration = <span class="keyword">new</span> Registration(commit.value().nodeId(), commit.session().sessionId().id());</div><div class="line">        elections.compute(topic, (k, v) -&gt; &#123;</div><div class="line">            <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ElectionState(registration, termCounter(topic)::incrementAndGet);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!v.isDuplicate(registration)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ElectionState(v).addRegistration(registration, termCounter(topic)::incrementAndGet);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> v;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Leadership newLeadership = leadership(topic);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!Objects.equal(oldLeadership, newLeadership)) &#123;</div><div class="line">            notifyLeadershipChange(oldLeadership, newLeadership);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> newLeadership;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        logger().error(<span class="string">"State machine operation failed"</span>, e);</div><div class="line">        <span class="keyword">throw</span> Throwables.propagate(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>LeadElector的创建流程</p>
<p> <code>LeadElector</code>是<code>LeadershipService</code>实现的基础，在<code>DistributedLeadershipStore</code>类中，一个<code>LeadElector</code>实例的创建方法如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">leaderElector = storageService.leaderElectorBuilder() <span class="comment">//1</span></div><div class="line">            .withName(<span class="string">"onos-leadership-elections"</span>) <span class="comment">//2</span></div><div class="line">            .build() <span class="comment">//3</span></div><div class="line">            .asLeaderElector(); <span class="comment">//4</span></div></pre></td></tr></table></figure>
<p> 其中，<strong>1</strong>方法在<code>StorageManager</code>类中实现，返回的是<code>DefaultLeaderElectorBuilder</code>类型，<code>DefaultLeaderElectorBuilder</code>传入的参数是实现了<code>DistributedPrimitiveCreator</code>接口的<code>FederatedDistributedPrimitiveCreator</code>类型的实例，该实例在<code>StorageManager</code>中初始化：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Activate</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">()</span> </span>&#123;</div><div class="line">    Map&lt;PartitionId, DistributedPrimitiveCreator&gt; partitionMap = Maps.newHashMap();</div><div class="line">    partitionService.getAllPartitionIds().stream()</div><div class="line">        .filter(id -&gt; !id.equals(PartitionId.from(<span class="number">0</span>)))</div><div class="line">        .forEach(id -&gt; partitionMap.put(id, partitionService.getDistributedPrimitiveCreator(id)));</div><div class="line">    federatedPrimitiveCreator = <span class="keyword">new</span> FederatedDistributedPrimitiveCreator(partitionMap);</div><div class="line">    transactionManager = <span class="keyword">new</span> TransactionManager(<span class="keyword">this</span>, partitionService);</div><div class="line">    log.info(<span class="string">"Started"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <strong>3</strong>方法将通过<code>FederatedDistributedPrimitiveCreator.newAsyncLeaderElector</code>方法创建一个<code>AsyncLeaderElector</code>，<code>FederatedDistributedPrimitiveCreator.newAsyncLeaderElector</code>方法实现如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> AsyncLeaderElector <span class="title">newAsyncLeaderElector</span><span class="params">(String name, <span class="keyword">long</span> leaderTimeout, TimeUnit timeUnit)</span> </span>&#123;</div><div class="line">    checkNotNull(name);</div><div class="line">    Map&lt;PartitionId, AsyncLeaderElector&gt; leaderElectors =</div><div class="line">            Maps.transformValues(members,</div><div class="line">                                 partition -&gt; partition.newAsyncLeaderElector(name, leaderTimeout, timeUnit));</div><div class="line">    Hasher&lt;String&gt; hasher = topic -&gt; &#123;</div><div class="line">        <span class="keyword">int</span> hashCode = Hashing.sha256().hashString(topic, Charsets.UTF_8).asInt();</div><div class="line">        <span class="keyword">return</span> sortedMemberPartitionIds.get(Math.abs(hashCode) % members.size());</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PartitionedAsyncLeaderElector(name, leaderElectors, hasher);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 其中<code>members</code>表示的是一个<code>Map&lt;PartitionId, DistributedPrimitiveCreator&gt;</code>类型的partitionMap，通过上面的代码片段可知该信息通过<code>partitionService</code>获得。由于ONOS对数据进行分片存储，分布式原语会在每一个partition上都创建一个实例。因此每一个partition都有一个<code>DistributedPrimitiveCreator</code>接口的实现，<code>StoragePartitionClient</code>负责该接口的最终实现，然后各个partition根据<code>StoragePartitionClient.newAsyncLeaderElector</code>方法创建一个<code>AsyncLeaderElector</code>实例，通过下面的代码片段可知<code>AsyncLeaderElector</code>最终是通过<code>AtomixLeaderElector</code>实现的：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> AsyncLeaderElector <span class="title">newAsyncLeaderElector</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    AtomixLeaderElector leaderElector = <span class="keyword">new</span> AtomixLeaderElector(client.newProxyBuilder()</div><div class="line">            .withName(name)</div><div class="line">            .withServiceType(DistributedPrimitive.Type.LEADER_ELECTOR.name())</div><div class="line">            .withReadConsistency(ReadConsistency.LINEARIZABLE)</div><div class="line">            .withCommunicationStrategy(CommunicationStrategy.LEADER)</div><div class="line">            .withTimeout(Duration.ofSeconds(<span class="number">5</span>)) <span class="comment">//5</span></div><div class="line">            .withMaxRetries(<span class="number">5</span>)</div><div class="line">            .build()</div><div class="line">            .open()</div><div class="line">            .join());</div><div class="line">    leaderElector.setupCache().join();</div><div class="line">    <span class="keyword">return</span> leaderElector;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 注意上面代码中的<strong>5</strong>方法设置该原语实例（client）与状态机会话（<code>RaftSession</code>）的timeout，即当一个client超过timeout指定的时间（5s）未与状态机有heartbeat交互时，该会话就会结束，并触发<code>AtomixLeaderElectorService</code>中的<code>onExpire</code>和<code>onClose</code>方法。上述代码返回一个<code>AtomixLeaderElector</code>实例，最后不同分片的<code>AtomixLeaderElector</code>实例封装在一个实现了<code>AsyncLeaderElector</code>接口的<code>PartitionedAsyncLeaderElector</code>对象中，以<code>run</code>方法为例，可知<code>PartitionedAsyncLeaderElector</code>会更据topic和hash函数，找到对应的partion中的<code>AtomixLeaderElector</code>实例，并执行<code>AtomixLeaderElector.run</code>方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Leadership&gt; <span class="title">run</span><span class="params">(String topic, NodeId nodeId)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getLeaderElector(topic).run(topic, nodeId);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the leaderElector (partition) to which the specified topic maps.</div><div class="line"> * <span class="doctag">@param</span> topic topic name</div><div class="line"> * <span class="doctag">@return</span> AsyncLeaderElector to which topic maps</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> AsyncLeaderElector <span class="title">getLeaderElector</span><span class="params">(String topic)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> partitions.get(topicHasher.hash(topic));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 另外，<strong>2</strong>方法设置该原语实例的名称，不同的原语实例需要使用不同的名称进行标记；<strong>4</strong>方法返回一个异步计算完成后的<code>LeaderElector</code>，即一个<code>DefaultLeaderElector</code>类型的实例。</p>
</li>
</ol>
<h1 id="5-ONOS-intra-clusters东西向通信"><a href="#5-ONOS-intra-clusters东西向通信" class="headerlink" title="5.  ONOS intra-clusters东西向通信"></a>5.  ONOS intra-clusters东西向通信</h1><p>ONOS集群内的多个instance间通过TCP连接建立通信(目的端口是9876)，包括Raft，Anti-entropy，Heatbeat以及其它的数据同步信息，ONOS通过数据包中的metadata来区分不同作用的数据信息。在任何两个ONOS实例间，可以同时建立多个TCP连接通信，这些TCP连接在需要时建立，若这些TCP连接空闲超过1min，TCP连接会中断。通过查看<code>ControllerNode</code>的代码实现，可以发现默认的9876端口信息：</p>
<p>ONOS基于Netty实现了一个异步的东西向通信消息服务接口（<code>MessagingService</code>），所有的东西通信都使用了这个消息服务接口，该消息接口是基于<strong>回调</strong>的思想实现的，<code>MessagingService</code>接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">/**</div><div class="line"> * Interface for low level messaging primitives.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessagingService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sends a message asynchronously to the specified communication end point.</div><div class="line">     * The message is specified using the type and payload.</div><div class="line">     * <span class="doctag">@param</span> ep end point to send the message to.</div><div class="line">     * <span class="doctag">@param</span> type type of message.</div><div class="line">     * <span class="doctag">@param</span> payload message payload bytes.</div><div class="line">     * <span class="doctag">@return</span> future that is completed when the message is sent</div><div class="line">     */</div><div class="line">    <span class="function">CompletableFuture&lt;Void&gt; <span class="title">sendAsync</span><span class="params">(Endpoint ep, String type, <span class="keyword">byte</span>[] payload)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sends a message asynchronously and expects a response.</div><div class="line">     * <span class="doctag">@param</span> ep end point to send the message to.</div><div class="line">     * <span class="doctag">@param</span> type type of message.</div><div class="line">     * <span class="doctag">@param</span> payload message payload.</div><div class="line">     * <span class="doctag">@return</span> a response future</div><div class="line">     */</div><div class="line">    CompletableFuture&lt;<span class="keyword">byte</span>[]&gt; sendAndReceive(Endpoint ep, String type, <span class="keyword">byte</span>[] payload);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sends a message synchronously and expects a response.</div><div class="line">     * <span class="doctag">@param</span> ep end point to send the message to.</div><div class="line">     * <span class="doctag">@param</span> type type of message.</div><div class="line">     * <span class="doctag">@param</span> payload message payload.</div><div class="line">     * <span class="doctag">@param</span> executor executor over which any follow up actions after completion will be executed.</div><div class="line">     * <span class="doctag">@return</span> a response future</div><div class="line">     */</div><div class="line">    CompletableFuture&lt;<span class="keyword">byte</span>[]&gt; sendAndReceive(Endpoint ep, String type, <span class="keyword">byte</span>[] payload, Executor executor);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Registers a new message handler for message type.</div><div class="line">     * <span class="doctag">@param</span> type message type.</div><div class="line">     * <span class="doctag">@param</span> handler message handler</div><div class="line">     * <span class="doctag">@param</span> executor executor to use for running message handler logic.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String type, BiConsumer&lt;Endpoint, <span class="keyword">byte</span>[]&gt; handler, Executor executor)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Registers a new message handler for message type.</div><div class="line">     * <span class="doctag">@param</span> type message type.</div><div class="line">     * <span class="doctag">@param</span> handler message handler</div><div class="line">     * <span class="doctag">@param</span> executor executor to use for running message handler logic.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String type, BiFunction&lt;Endpoint, <span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; handler, Executor executor)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Registers a new message handler for message type.</div><div class="line">     * <span class="doctag">@param</span> type message type.</div><div class="line">     * <span class="doctag">@param</span> handler message handler</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String type, BiFunction&lt;Endpoint, <span class="keyword">byte</span>[], CompletableFuture&lt;<span class="keyword">byte</span>[]&gt;&gt; handler)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Unregister current handler, if one exists for message type.</div><div class="line">     * <span class="doctag">@param</span> type message type</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterHandler</span><span class="params">(String type)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的消息服务接口中的每一个方法都有一个<code>String type</code>类型参数，表示的是该消息的类型。当消息到达<code>Endpoint</code>时，<code>MessagingService</code>会根据<code>registerHandler</code>注册的方法调用对应消息类型的处理方法，即message handler，从而完成消息的处理。</p>
<p>同时，为了方便使用东西向通信服务，ONOS又提供了一个集群通信服务服务接口（<code>ClusterCommunicationService</code>）,通过使用该服务，可以很容易的实现东西数据的传输和处理。很多的最终一致性store都使用了<code>ClusterCommunicationService</code>，如<code>ECDeviceStore</code>，<code>ECLinkStore</code>，<code>DistributedFlowRuleStore</code>等，同时<code>EventuallyConsistentMapImpl</code>中的anti-entropy的实现也都使用了该服务。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ONOS是一个分布式的控制器，为了提高数据的读写效率，采用自实现的基于In-Memory的Key-Value数据存储系统。针对实际的需要，不同的数据模型采用不同的数据一致性方法，即强一致性（strong consistency）和最终一致性（eventually consistency）。ONOS使用raft协议实现强一致性，使用anti-entropy（gossip）协议实现最终一致性。&lt;/p&gt;
    
    </summary>
    
      <category term="ONOS" scheme="http://yoursite.com/categories/ONOS/"/>
    
    
      <category term="ONOS" scheme="http://yoursite.com/tags/ONOS/"/>
    
      <category term="distributed store" scheme="http://yoursite.com/tags/distributed-store/"/>
    
  </entry>
  
  <entry>
    <title>Flow Rule Subsystem简要分析</title>
    <link href="http://yoursite.com/2017/01/15/Flow-Rule-Subsystem%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/01/15/Flow-Rule-Subsystem简要分析/</id>
    <published>2017-01-15T04:43:35.000Z</published>
    <updated>2017-07-08T17:14:00.048Z</updated>
    
    <content type="html"><![CDATA[<p>Flow Rule Subsystem实现Flow rule的管理，存储和同步，用户可通过Flow Rule Subsystem提供的北向API（FlowRuleService）查询，下发和删除Flow rule。下面将结合Flow Rule Subsystem的代码，并以OpenFlow为例，简要分析Flow Rule Subsystem的实现过程，希望以此抛砖引玉。</p>
<a id="more"></a>
<p>分析Flow Rule Subsystem之前，我们需要对ONOS的子系统结构（Subsystem Structure）和事件（Event）机制有比较好的了解，参考<a href="https://baymaxhuang.github.io/2017/01/05/ONOS%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">ONOS子系统结构和事件调度处理机制</a></p>
<h1 id="Flow-Rule-Subsystem分析"><a href="#Flow-Rule-Subsystem分析" class="headerlink" title="Flow Rule Subsystem分析"></a>Flow Rule Subsystem分析</h1><p>在ONOS Core层，Flow Rule Subsystem的实现主要包括FlowRuleManager和DistributedFlowRuleStore这两个类，FlowRuleManager负责北向和南向接口的实现（FlowRuleService，FlowProviderService，FlowRuleProviderService等），是子系统的中枢，而DistributedFlowRuleStore负责数据的存储同步，是分布式实现的核心。下面是这两个类的UML图，</p>
<p>FlowRuleManger类结构图：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/FlowRuleManger.png" alt=""></p>
<p>DistributedFlowRuleStore类结构图：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/DistributedFlowRuleStore.png" alt=""></p>
<p>下面将以FlowRuleService方法applyFlowRules实现过程简要分析Flow Rule子系统。</p>
<ol>
<li><p>每一个flowRule被封装成一个FlowRuleOperation，不同flowRule的集合被封装成一个FlowRuleOperations，然后调用apply方法。看代码注释，FlowRuleOperations是被分解成不同stage的FlowRuleOperation的集合，每一个stage是一组FlowRuleOperation的集合，不同stage的FlowRuleOperation集合保存在list中：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* A batch of flow rule operations that are broken into stages.</div><div class="line">* TODO move this up to parent's package</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowRuleOperations</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Set&lt;FlowRuleOperation&gt;&gt; stages;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FlowRuleOperationsContext callback;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FlowRuleOperations</span><span class="params">(List&lt;Set&lt;FlowRuleOperation&gt;&gt; stages,</span></span></div><div class="line">                            FlowRuleOperationsContext cb) &#123;</div><div class="line">        <span class="keyword">this</span>.stages = stages;</div><div class="line">        <span class="keyword">this</span>.callback = cb;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// kryo-constructor</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FlowRuleOperations</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.stages = Lists.newArrayList();</div><div class="line">        <span class="keyword">this</span>.callback = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> ONOS使用多线程的方式下发流表，但保证不同stage间FlowRuleOperation的下发是有顺序的，例如要使flowRule1在flowRule2之前下发完成，可以使用如下的方式构造不同stage的FlowRuleOperation：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FlowRuleOperations.Builder ops = FlowRuleOperations.builder();</div><div class="line">ops.add(flowRule1);</div><div class="line">ops.newStage();</div><div class="line">ops.add(flowRule2);</div><div class="line">flowRuleService.apply(ops.build());</div></pre></td></tr></table></figure>
</li>
<li><p>apply方法中，将FlowRuleOperations放到一个线程容量为32的线程池中处理：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line"><span class="keyword">protected</span> ExecutorService operationsService =</div><div class="line">            Executors.newFixedThreadPool(<span class="number">32</span>, groupedThreads(<span class="string">"onos/Flowservice"</span>, <span class="string">"operations-%d"</span>, log));</div><div class="line">......</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(FlowRuleOperations ops)</span> </span>&#123;</div><div class="line">    checkPermission(FlowRULE_WRITE);</div><div class="line">    operationsService.execute(<span class="keyword">new</span> FlowOperationsProcessor(ops));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>下面是FlowOperationsProcessor类的代码，熟悉Java多线程编程的应该知道，新建的线程会运行run()方法，而FlowOperationsProcessor中的run方法调用了process方法处理FlowRuleOperation。这里使用了一个Multimap (Multimap<deviceid, flowrulebatchentry=""> perDeviceBatches) 来保存要下发到每个Device的Flow Rules的集合，每个Flow Rule被封装成一个FlowRuleBatchEntry类型的对象，保存在perDeviceBatches中。这样就以Device为单位将所有的FLow Rules进行归类，然后针对不同的Device逐个下发FlowRuleBatchOperation（就是一组待下发的Flow Rules集合）。这个类中，还有一个重要的属性pendingDevices，用来保存所有待下发Flow Rule的DeviceId的集合。当一个Device的FlowRuleBatchOperation下发完成后，该Device的DeviceId也会从pendingDevices移除，这个操作在satisfy方法中实现。并且当pendingDevices为空，即该stage的所有FlowRuleOperation下发完成后，就会调用operationsService.execute(this)进入下一个stage。从run方法可以看出，若所有的stages已经完成，并且没有出现过失败记录，那么就会回调FlowRuleOperations的onSuccess方法，通知应用程序所有的Flow Rules已经成功下发。</deviceid,></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowOperationsProcessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">// Immutable</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FlowRuleOperations fops;</div><div class="line"></div><div class="line">    <span class="comment">// Mutable</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Set&lt;FlowRuleOperation&gt;&gt; stages;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;DeviceId&gt; pendingDevices = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasFailed = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    FlowOperationsProcessor(FlowRuleOperations ops) &#123;</div><div class="line">        <span class="keyword">this</span>.stages = Lists.newArrayList(ops.stages());</div><div class="line">        <span class="keyword">this</span>.fops = ops;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!stages.isEmpty()) &#123;</div><div class="line">            process(stages.remove(<span class="number">0</span>));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFailed) &#123;</div><div class="line">            fops.callback().onSuccess(fops);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Set&lt;FlowRuleOperation&gt; ops)</span> </span>&#123;</div><div class="line">        Multimap&lt;DeviceId, FlowRuleBatchEntry&gt; perDeviceBatches = ArrayListMultimap.create();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (FlowRuleOperation op : ops) &#123;</div><div class="line">            perDeviceBatches.put(op.rule().deviceId(),</div><div class="line">                    <span class="keyword">new</span> FlowRuleBatchEntry(mapOperationType(op.type()), op.rule()));</div><div class="line">        &#125;</div><div class="line">        pendingDevices.addAll(perDeviceBatches.keySet());</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (DeviceId deviceId : perDeviceBatches.keySet()) &#123;</div><div class="line">            <span class="keyword">long</span> id = idGenerator.getNewId();</div><div class="line">            <span class="keyword">final</span> FlowRuleBatchOperation b = <span class="keyword">new</span> FlowRuleBatchOperation(perDeviceBatches.get(deviceId),</div><div class="line">                                           deviceId, id);</div><div class="line">            pendingFlowOperations.put(id, <span class="keyword">this</span>);</div><div class="line">            log.info(<span class="string">"begin install flow rules to device &#123;&#125; with size &#123;&#125;"</span>, deviceId, b.getOperations().size());</div><div class="line">            deviceInstallers.execute(() -&gt; store.storeBatch(b));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">satisfy</span><span class="params">(DeviceId devId)</span> </span>&#123;</div><div class="line">        pendingDevices.remove(devId);</div><div class="line">        <span class="keyword">if</span> (pendingDevices.isEmpty()) &#123;</div><div class="line">            operationsService.execute(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(DeviceId devId, Set&lt;? extends FlowRule&gt; failures)</span> </span>&#123;</div><div class="line">        hasFailed = <span class="keyword">true</span>;</div><div class="line">        pendingDevices.remove(devId);</div><div class="line">        <span class="keyword">if</span> (pendingDevices.isEmpty()) &#123;</div><div class="line">            operationsService.execute(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        FlowRuleOperations.Builder failedOpsBuilder = FlowRuleOperations.builder();</div><div class="line">        failures.forEach(failedOpsBuilder::add);</div><div class="line"></div><div class="line">        fops.callback().onError(failedOpsBuilder.build());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>正如在1.1节中介绍的那样，Manager有关数据信息的操作都会通过store来完成。这里，通过调用store.storeBatch将Flow rule信息添加到FlowRuleStore中。store.storeBatch也是在一个新的线程池中处理的,deviceInstallers的声明如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> ExecutorService deviceInstallers =</div><div class="line">            Executors.newFixedThreadPool(<span class="number">32</span>, groupedThreads(<span class="string">"onos/Flowservice"</span>, <span class="string">"device-installer-%d"</span>, log));</div></pre></td></tr></table></figure>
</li>
<li><p>storeBatch具体的实现细节比较复杂，如要判断FlowRuleBatchOperation的设备是否有对应的master控制器节点，以及当前的节点是否就是master控制器节点，这是因为FlowRule需要存储到device对应的master控制器节点的FlowRuleStore中，并由master节点下发到对应的device，具体的操作过程看DistributedFlowRuleStore的源码。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">storeBatch</span><span class="params">(FlowRuleBatchOperation operation)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (operation.getOperations().isEmpty()) &#123;</div><div class="line">        notifyDelegate(FlowRuleBatchEvent.completed(</div><div class="line">                <span class="keyword">new</span> FlowRuleBatchRequest(operation.id(), Collections.emptySet()),</div><div class="line">                <span class="keyword">new</span> CompletedBatchOperation(<span class="keyword">true</span>, Collections.emptySet(), operation.deviceId())));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    DeviceId deviceId = operation.deviceId();</div><div class="line">    NodeId master = mastershipService.getMasterFor(deviceId);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (master == <span class="keyword">null</span>) &#123;</div><div class="line">        log.warn(<span class="string">"No master for &#123;&#125; : flows will be marked for removal"</span>, deviceId);</div><div class="line"></div><div class="line">        updateStoreInternal(operation);</div><div class="line"></div><div class="line">        notifyDelegate(FlowRuleBatchEvent.completed(</div><div class="line">                <span class="keyword">new</span> FlowRuleBatchRequest(operation.id(), Collections.emptySet()),</div><div class="line">                <span class="keyword">new</span> CompletedBatchOperation(<span class="keyword">true</span>, Collections.emptySet(), operation.deviceId())));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (Objects.equals(local, master)) &#123;</div><div class="line">        storeBatchInternal(operation);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    log.trace(<span class="string">"Forwarding storeBatch to &#123;&#125;, which is the primary (master) for device &#123;&#125;"</span>,</div><div class="line">              master, deviceId);</div><div class="line"></div><div class="line">    clusterCommunicator.unicast(operation,</div><div class="line">                                APPLY_BATCH_FLOWS,</div><div class="line">                                serializer::encode,</div><div class="line">                                master)</div><div class="line">                       .whenComplete((result, error) -&gt; &#123;</div><div class="line">                           <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</div><div class="line">                               log.warn(<span class="string">"Failed to storeBatch: &#123;&#125; to &#123;&#125;"</span>, operation, master, error);</div><div class="line"></div><div class="line">                               Set&lt;FlowRule&gt; allFailures = operation.getOperations()</div><div class="line">                                       .stream()</div><div class="line">                                       .map(op -&gt; op.target())</div><div class="line">                                       .collect(Collectors.toSet());</div><div class="line"></div><div class="line">                               notifyDelegate(FlowRuleBatchEvent.completed(</div><div class="line">                                       <span class="keyword">new</span> FlowRuleBatchRequest(operation.id(), Collections.emptySet()),</div><div class="line">                                       <span class="keyword">new</span> CompletedBatchOperation(<span class="keyword">false</span>, allFailures, deviceId)));</div><div class="line">                           &#125;</div><div class="line">                       &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 需要注意的是，若当前控制器不是对应device的master节点，storeBatch会使用ClusterCommunicationService服务的unicast方法，将该FlowRuleBatchOperation发送到对应的master控制器节点，Remote节点处理完成后会将处理的结果告诉该控制器节点。同时，DistributedFlowRuleStore使用ClusterCommunicationService服务的addSubscriber来监听东西向发送的FlowRule消息，并做出对应的处理。下面的APPLY_BATCH_FLOWS消息表示Remote节点将Flow Rules交给本地节点协助下发，而REMOTE_APPLY_COMPLETED消息则表示由Remote节点协助本地节点下发的Flow Rule已经下发完成，并调用notifyDelegate产生事件。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerMessageHandlers</span><span class="params">(ExecutorService executor)</span> </span>&#123;</div><div class="line"></div><div class="line">    clusterCommunicator.addSubscriber(APPLY_BATCH_FLOWS, <span class="keyword">new</span> OnStoreBatch(), executor);</div><div class="line">    clusterCommunicator.&lt;FlowRuleBatchEvent&gt;addSubscriber(</div><div class="line">            REMOTE_APPLY_COMPLETED, serializer::decode, <span class="keyword">this</span>::notifyDelegate, executor);</div><div class="line">    clusterCommunicator.addSubscriber(</div><div class="line">            GET_FLOW_ENTRY, serializer::decode, flowTable::getFlowEntry, serializer::encode, executor);</div><div class="line">    clusterCommunicator.addSubscriber(</div><div class="line">            GET_DEVICE_FLOW_ENTRIES, serializer::decode, flowTable::getFlowEntries, serializer::encode, executor);</div><div class="line">    clusterCommunicator.addSubscriber(</div><div class="line">            REMOVE_FLOW_ENTRY, serializer::decode, <span class="keyword">this</span>::removeFlowRuleInternal, serializer::encode, executor);</div><div class="line">    clusterCommunicator.addSubscriber(</div><div class="line">            FLOW_TABLE_BACKUP, serializer::decode, flowTable::onBackupReceipt, serializer::encode, executor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 最后，storeBatch中调用notifyDelegate函数向FlowRuleStoreDelegate通告FlowRuleStore中产生的事件，事件的类型在FlowRuleBatchEvent中定义。前一篇文章已经分析过，AbstractStore实现了notifyDelegate方法，而DistributedFlowRuleStore继承了AbstractStore类，因此可以调用notifyDelegate方法。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line">notifyDelegate(FlowRuleBatchEvent.requested(<span class="keyword">new</span></div><div class="line">                    FlowRuleBatchRequest(operation.id(),</div><div class="line">                                        currentOps), operation.deviceId()));</div><div class="line">......</div><div class="line"><span class="comment">/**</span></div><div class="line">* Notifies the delegate with the specified event.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> event event to delegate</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyDelegate</span><span class="params">(E event)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (delegate != <span class="keyword">null</span>) &#123;</div><div class="line">        delegate.notify(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>上述代码块中delegate成员是在FlowRuleManager中注册到FlowRuleStore中来的，实现代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> FlowRuleStoreDelegate delegate = <span class="keyword">new</span> InternalStoreDelegate();</div><div class="line">······</div><div class="line"><span class="meta">@Activate</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">(ComponentContext context)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    store.setDelegate(delegate);</div><div class="line">    eventDispatcher.addSink(FlowRuleEvent.class, listenerRegistry);</div><div class="line">    deviceService.addListener(deviceListener);</div><div class="line">    ......</div><div class="line">    log.info(<span class="string">"Started"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>FlowRuleManager的内部类实现FlowRuleStoreDelegate接口，通过实现notify函数来处理来自FlowRueStore中产生的事件。这里post函数时最终会使用EventDeliveryService调度事件，其它应用组件通过实现FlowRuleListener接口，创建监听者并注册到FlowRuleManager中即可监听post抛出的事件，通过FlowRuleService.addListener()完成监听者的注册。ONOS中的StatisticManager模块中有一个实现了FlowRuleListener接口的内部类。根据上面的分析过程，storeBatch函数会产生BATCH_OPERATION_COMPLETED类型的事件，因此会通过FlowRuleProvider FlowRuleProvider = getProvider(deviceId)获取ProviderId，getProvider函数在AbstractProviderRegistry类中实现，FlowRuleManager继承了这个类，所有的Provider都会注册到FlowRuleManager，并保存在一个map中，具体实现查看AbstractProviderRegistry的源码。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Store delegate to re-post events emitted from the store.</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalStoreDelegate</span> <span class="keyword">implements</span> <span class="title">FlowRuleStoreDelegate</span> </span>&#123;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> Right now we only dispatch events at individual FlowEntry level.</span></div><div class="line">    <span class="comment">// It may be more efficient for also dispatch events as a batch.</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(FlowRuleBatchEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> FlowRuleBatchRequest request = event.subject();</div><div class="line">        <span class="keyword">switch</span> (event.type()) &#123;</div><div class="line">        <span class="keyword">case</span> BATCH_OPERATION_REQUESTED:</div><div class="line">            <span class="comment">// Request has been forwarded to MASTER Node, and was</span></div><div class="line">            request.ops().forEach(</div><div class="line">                    op -&gt; &#123;</div><div class="line">                        <span class="keyword">switch</span> (op.operator()) &#123;</div><div class="line">                            <span class="keyword">case</span> ADD:</div><div class="line">                                post(<span class="keyword">new</span> FlowRuleEvent(RULE_ADD_REQUESTED, op.target()));</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">case</span> REMOVE:</div><div class="line">                                post(<span class="keyword">new</span> FlowRuleEvent(RULE_REMOVE_REQUESTED, op.target()));</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">case</span> MODIFY:</div><div class="line">                                <span class="comment">//<span class="doctag">TODO:</span> do something here when the time comes.</span></div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">default</span>:</div><div class="line">                                log.warn(<span class="string">"Unknown Flow operation operator: &#123;&#125;"</span>, op.operator());</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">            );</div><div class="line"></div><div class="line">            DeviceId deviceId = event.deviceId();</div><div class="line">            FlowRuleBatchOperation batchOperation = request.asBatchOperation(deviceId);</div><div class="line">            FlowRuleProvider FlowRuleProvider = getProvider(deviceId);</div><div class="line">            <span class="keyword">if</span> (FlowRuleProvider != <span class="keyword">null</span>) &#123;</div><div class="line">                FlowRuleProvider.executeBatch(batchOperation);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> BATCH_OPERATION_COMPLETED:</div><div class="line">        ......</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>以OpenFlow为例，OpenFlowRuleProvider实现了FlowRuleProvider接口，并使用FlowRuleProviderRegistry服务将该Provider注册到FlowRuleManager上。OpenFlowRuleProvider中的executeBatch的方法会将FlowRuleBatchOperation转化成OpenFlow的消息格式并下发到对应的交换机上。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Reference</span>(cardinality = ReferenceCardinality.MANDATORY_UNARY)</div><div class="line"><span class="keyword">protected</span> FlowRuleProviderRegistry providerRegistry;</div><div class="line">......</div><div class="line"><span class="keyword">private</span> FlowRuleProviderService providerService;</div><div class="line">......</div><div class="line"><span class="meta">@Activate</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">(ComponentContext context)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    providerService = providerRegistry.register(<span class="keyword">this</span>);</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>以上就是FlowRule子系统下发flow rule的过程了，需要注意的是，任何ONOS instance可以向flow service请求对网络中的任何设备下发flow rule，但当这个网络设的master不是当前的ONOS instance时，该flow rule会被发送到设备的master instance，最终由master instance完成flow rule的下发操作。具体的实现过程在上面已经结合代码进行分析了，如下图所示：</p>
</li>
</ol>
<p><img src="http://oj37kd49l.bkt.clouddn.com/onos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image2.png" alt="image2"></p>
<h1 id="3-Flow-Rule的存储"><a href="#3-Flow-Rule的存储" class="headerlink" title="3. Flow Rule的存储"></a>3. Flow Rule的存储</h1><p>Flow rule的存储通过DistributedFlowRuleStore来实现，实现的接口服务是FlowRuleStore，需要考虑存储，备份，以及同步等问题。需要注意的是，ONOS会存储Flow rule并保持控制器和网络设备中Flow rule信息的一致性，若控制器发现了网络设备中有控制器没有存储的Flow rule条目，ONOS会将该Flow rule删除。同时，当master控制器对它的subnet中的device下发Flow rule信息后，会选择一个或多个（默认设置是2个备份节点，参考DistributedFlowRuleStore源码）其它的standby节点备份flowrule信息，从而使得当前节点down掉后能够恢复Flow rule信息。通常优先选择当前节点down掉后，接管该subnet的standby节点作为备份节点。</p>
<p><em>注</em>：</p>
<p>ONOS控制器各个node节点与device设备有三种mastership关系：</p>
<ul>
<li>NONE：这意味着node并不了解该设备，或仅仅是无法与其交互</li>
<li>STANDBY：此时node已经有对设备的认识，并可以读取其状态，但无法管理、控制该设备</li>
<li>MASTER：此时node认识设备并对其有完全的控制权</li>
</ul>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>总的来说，Flow Rule Subsystem的实现是比较复杂的，但其代码结构却很清晰。本文分析了Flow Rule子系统的代码结构，并结合Flow Rule的下发过程代码简单分析了Flow Rule子系统。若要了解Flow Rule的更多实现细节，需要进一步的阅读源码。</p>
<p>参考：</p>
<ul>
<li><a href="https://wiki.onosproject.org/display/ONOS/System+Components" target="_blank" rel="external">ONOS System Components</a></li>
<li><a href="https://wiki.onosproject.org/display/ONOS/Flow+Rule+Subsystem" target="_blank" rel="external">ONOS Flow Rule Subsystem</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flow Rule Subsystem实现Flow rule的管理，存储和同步，用户可通过Flow Rule Subsystem提供的北向API（FlowRuleService）查询，下发和删除Flow rule。下面将结合Flow Rule Subsystem的代码，并以OpenFlow为例，简要分析Flow Rule Subsystem的实现过程，希望以此抛砖引玉。&lt;/p&gt;
    
    </summary>
    
      <category term="ONOS" scheme="http://yoursite.com/categories/ONOS/"/>
    
    
      <category term="ONOS" scheme="http://yoursite.com/tags/ONOS/"/>
    
      <category term="FlowRule" scheme="http://yoursite.com/tags/FlowRule/"/>
    
      <category term="Subsystem" scheme="http://yoursite.com/tags/Subsystem/"/>
    
  </entry>
  
  <entry>
    <title>ONOS子系统结构和事件分发处理机制</title>
    <link href="http://yoursite.com/2017/01/05/ONOS%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/01/05/ONOS子系统结构和事件分发处理机制/</id>
    <published>2017-01-04T16:09:20.000Z</published>
    <updated>2017-03-27T07:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>ONOS是一个支持分布式的复杂网络操作系统，ONOS的设计高度层次化，模块化和抽象化，ONOS不同的模块和组件一般都使用特定的接口类型和异步事件机制通信协作。因此，理解ONOS子系统结构和事件分发处理机制对进一步深入了解ONOS是有很大帮助的。</p>
<a id="more"></a>
<h1 id="1-ONOS子系统结构"><a href="#1-ONOS子系统结构" class="headerlink" title="1. ONOS子系统结构"></a>1. ONOS子系统结构</h1><p>ONOS有很多子系统，但不同的子系统的层次和结构是相同的。下面是ONOS子系统的结构图：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/ONOS%20Subsystem%20Structure.png" alt=""></p>
<p>ONOS子系统主要包括App，Core，Provider，Protocol四部分。其中，Core是对网络的抽象，是协议无关的(protocol agnostic), 对上提供统一抽象的北向接口。Core中的组件主要包括Manager和Store，如FlowRuleManager和FlowRuleStore等。而Provider是协议相关的，主要为ONOS Core提供抽象的数据类型，Provider通过Core提供的ProviderService接口向Core注入网络信息，Provider也会暴露Provider接口给Core，接收来自Core的command消息。Protocol模块则是根据特定的协议类型通网路设备建立连接，Protocol模块一般是和对应的Provider模块共同启动的。</p>
<p>其中，Core中的Manager和Store是本次分析的重点。Manager对北实现Service和AdminService接口，对南实现ProviderRegistry和 ProviderService接口。Store则负责数据的存储，查询，更新以及东西向同步等，所有来自Manager中与数据相关的操作都会通过Store来完成。另外，Manager也会将Store中的事件抛出并实现ListenerService接口，其它应用通过ListenerService接口即可实现事件的监听，下面将详细分析这一过程。</p>
<h1 id="2-ONOS系统事件分发处理机制"><a href="#2-ONOS系统事件分发处理机制" class="headerlink" title="2. ONOS系统事件分发处理机制"></a>2. ONOS系统事件分发处理机制</h1><h2 id="2-1-了解ONOS系统中的事件Event和EventSink"><a href="#2-1-了解ONOS系统中的事件Event和EventSink" class="headerlink" title="2.1 了解ONOS系统中的事件Event和EventSink"></a>2.1 了解ONOS系统中的事件Event和EventSink</h2><p>事件一般是由Store产生，用一种特定的类来表示一种事件类型，如AppIdEvent，DeviceEvent，FLowRuleEvent等，所有的事件类型实现Event接口，Event包括事件类型和事件主题，分别通过枚举类型和字符串类型来表示，表示一种特定的事件类型。每个事件最终会分发到一个对应的事件槽（EventSink），即事件传播处理的终点，系统调用事件槽的process函数处理对应的事件。下面分别是Event和EventSink的接口定义源码，二者都是泛型接口，接口的源码注释清楚的说明了这两个接口的作用。</p>
<p>Event接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Abstraction of an of a time-stamped event pertaining to an arbitrary subject.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Event</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Enum</span>, <span class="title">S</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the timestamp of when the event occurred, given in milliseconds</div><div class="line">     * since the start of epoch.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> timestamp in milliseconds</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">time</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the type of the event.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> event type</div><div class="line">     */</div><div class="line">    <span class="function">T <span class="title">type</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the subject of the event.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> subject to which this event pertains</div><div class="line">     */</div><div class="line">    <span class="function">S <span class="title">subject</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>EventSink接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Abstraction of an event sink capable of processing the specified event types.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventSink</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Event</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Processes the specified event.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> event event to be processed</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(E event)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Handles notification that event processing time limit has been exceeded.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onProcessLimit</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-2-事件的分发服务EventDeliveryService"><a href="#2-2-事件的分发服务EventDeliveryService" class="headerlink" title="2.2 事件的分发服务EventDeliveryService"></a>2.2 事件的分发服务EventDeliveryService</h2><p><img src="http://oj37kd49l.bkt.clouddn.com/EventDeliveryService.png" alt=""></p>
<p>上面是EventDeliveryService的UML图，可以很容易的发现EventDeliveryService继承了两个接口，EventDispatcher和EventSinkRegistry，前者负责事件的分发（post），后者负责事件槽的管理（addSink和removeSink），ONOS子系统通过使用该服务，就能实现将事件正确分发到对应的事件槽，EventDeliveryService一般在子系统的Manager中使用。</p>
<h2 id="2-3-EventDeliveryService服务的实现"><a href="#2-3-EventDeliveryService服务的实现" class="headerlink" title="2.3 EventDeliveryService服务的实现"></a>2.3 EventDeliveryService服务的实现</h2><p>EventDeliveryService服务是通过CoreEventDispatcher类来实现，该类被声明为一个OSGi Component，由OSGi进行管理。废话不多说，还是直接看CoreEventDispatcher的UML结构图：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/CoreEventDispatcher.png" alt=""></p>
<p>由于该类比较复杂，没有显示该类的成员变量。事件的最终分发处理是由内部类DispatchLoop处理，该类实现了Runnable接口，从而使用独立的线程处理特定的事件组。DispatchLoop里有一个保存事件队列的重要成员变量eventsQueue，声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Auxiliary event dispatching loop that feeds off the events queue.</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stopped;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> EventSink lastSink;</div><div class="line">    <span class="comment">// Means to detect long-running sinks</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stopwatch stopwatch = Stopwatch.createUnstarted();</div><div class="line">    <span class="keyword">private</span> TimerTask watchdog;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Future&lt;?&gt; dispatchFuture;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Event&gt; eventsQueue;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>eventsQueue是BlockingQueue<event>类型，是一个阻塞队列，关于Java阻塞队列的功能和作用，参考：<a href="http://www.infoq.com/cn/articles/java-blocking-queue" target="_blank" rel="external">聊聊并发（七）——Java中的阻塞队列</a>。EventDeliveryService的post方法最终会调用DispatchLoop的add方法将事件加入到这个队列，是程序主动调用的，DispatchLoop里的线程方法（run）会不断的取出事件并调用对应的事件槽处理函数处理对应事件。熟悉多线程协作以及设计模式的朋友应该会注意到这里所用的也就是<strong>生产者-消费者模式</strong>，参考：<a href="http://www.infoq.com/cn/articles/producers-and-consumers-mode" target="_blank" rel="external">聊聊并发——生产者消费者模式</a>。</event></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    stopped = <span class="keyword">false</span>;</div><div class="line">    log.info(<span class="string">"Dispatch loop initiated"</span>);</div><div class="line">    <span class="keyword">while</span> (!stopped) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// Fetch the next event and if it is the kill-pill, bail</span></div><div class="line">            Event event = eventsQueue.take();</div><div class="line">            <span class="keyword">if</span> (event == KILL_PILL) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            process(event);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            log.warn(<span class="string">"Dispatch loop interrupted"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception | Error e) &#123;</div><div class="line">            log.warn(<span class="string">"Error encountered while dispatching event:"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    log.info(<span class="string">"Dispatch loop terminated"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Locate the sink for the event class and use it to process the event</span></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Event event)</span> </span>&#123;</div><div class="line">    EventSink sink = getSink(event.getClass());</div><div class="line">    <span class="keyword">if</span> (sink != <span class="keyword">null</span>) &#123;</div><div class="line">        lastSink = sink;</div><div class="line">        stopwatch.start();</div><div class="line">        sink.process(event);</div><div class="line">        stopwatch.reset();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        log.warn(<span class="string">"No sink registered for event class &#123;&#125;"</span>,</div><div class="line">                    event.getClass().getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是CoreEventDispatcher分发处理事件到对应事件槽的大概流程，这里就不对CoreEventDispatcher的实现细节进一步分析了，要了解程序的更多实现细节，需要阅读源码。</p>
<h2 id="2-4-添加事件监听者处理事件"><a href="#2-4-添加事件监听者处理事件" class="headerlink" title="2.4 添加事件监听者处理事件"></a>2.4 添加事件监听者处理事件</h2><p>下面是ONOS子系统中的事件分发示意图：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/ONOS%20Event.png" alt=""></p>
<p>Manager对数据的操作导致Store产生事件，Store通过StoreDelegate的notify方法向Manager通告事件。AbstractStore类中有基本Store接口的实现，一般Store的实现类都会继承AbstractStore基础类，该类中的notifyDelegate方法会调用StoreDelegate的notify方法。Manager使用内部类实现StoreDelegate接口，notify方法的实现会调用post方法，post方法最终使用EventDeliveryService服务分发事件。post方法在AbstractListenerManager或AbstractListenerProviderRegistry中有实现，Manager组件一般都会继承AbstractListenerManager或AbstractListenerProviderRegistry基础类。下面是AbstractStore和AbstractListenerProviderRegistry的UML图如下所示：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/AbstractProviderRegistry.png" alt=""></p>
<p>外部应用通过实现EventListener接口构造一个事件监听者，使用ListenerService的addListener方法完成监听者的注册，AbstractListenerManager和AbstractListenerProviderRegistry类都实现了ListenerService接口。AbstractListenerManager或AbstractListenerProviderRegistry基础类中有一个重要的对象成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ListenerRegistry&lt;E, L&gt; listenerRegistry = <span class="keyword">new</span> ListenerRegistry&lt;&gt;();</div><div class="line">.....</div></pre></td></tr></table></figure>
<p>监听者注册最终会使用调用该成员对象的addListener方法，ListenerRegistry实现了ListenerService和EventSink接口，从而将事件(Event)，事件槽(EventSink)，监听者(EventListener)联系起来。</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/ListenerRegistry.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Base implementation of an event sink and a registry capable of tracking</div><div class="line"> * listeners and dispatching events to them as part of event sink processing.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerRegistry</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Event</span>, <span class="title">L</span> <span class="keyword">extends</span> <span class="title">EventListener</span>&lt;<span class="title">E</span>&gt;&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">ListenerService</span>&lt;<span class="title">E</span>, <span class="title">L</span>&gt;, <span class="title">EventSink</span>&lt;<span class="title">E</span>&gt; &#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Set of listeners that have registered.</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Set&lt;L&gt; listeners = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(L listener)</span> </span>&#123;</div><div class="line">        checkNotNull(listener, <span class="string">"Listener cannot be null"</span>);</div><div class="line">        listeners.add(listener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(L listener)</span> </span>&#123;</div><div class="line">        checkNotNull(listener, <span class="string">"Listener cannot be null"</span>);</div><div class="line">        <span class="keyword">if</span> (!listeners.remove(listener)) &#123;</div><div class="line">            log.warn(<span class="string">"Listener &#123;&#125; not registered"</span>, listener);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(E event)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (L listener : listeners) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                lastListener = listener;</div><div class="line">                lastStart = System.currentTimeMillis();</div><div class="line">                <span class="keyword">if</span> (listener.isRelevant(event)) &#123;</div><div class="line">                    listener.event(event);</div><div class="line">                &#125;</div><div class="line">                lastStart = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception error) &#123;</div><div class="line">                reportProblem(event, error);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ListenerRegistry使用线程安全的集合CopyOnWriteArraySet管理监听者，EventSink的process方法就是逐个的执行EventListener的event方法。Manager使用EventDeliveryService的addSink方法将自己管理的事件和对应的事件槽联系起来。下面是FlowRuleManager的代码示例：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> FlowRuleStoreDelegate delegate = <span class="keyword">new</span> InternalStoreDelegate();</div><div class="line">······</div><div class="line"><span class="meta">@Activate</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">(ComponentContext context)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    store.setDelegate(delegate);</div><div class="line">    eventDispatcher.addSink(FlowRuleEvent.class, listenerRegistry);</div><div class="line">    ......</div><div class="line">    log.info(<span class="string">"Started"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>总的来说，ONOS子系统功能复杂但结构清晰，ONOS子系统的结构具有模块化，层次化，抽象化的特点。Manager是子系统的核心，负责将服务，存储，以及事件联系起来。Manager实现ListenerService接口，管理事件监听者的注册和移除，事件的分发和处理调度由EventDeliveryService统一管理。</p>
<p>参考：</p>
<ul>
<li><a href="https://wiki.onosproject.org/display/ONOS/System+Components" target="_blank" rel="external">ONOS System Components</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-blocking-queue" target="_blank" rel="external">聊聊并发（七）——Java中的阻塞队列</a></li>
<li><a href="http://www.infoq.com/cn/articles/producers-and-consumers-mode" target="_blank" rel="external">聊聊并发——生产者消费者模式</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ONOS是一个支持分布式的复杂网络操作系统，ONOS的设计高度层次化，模块化和抽象化，ONOS不同的模块和组件一般都使用特定的接口类型和异步事件机制通信协作。因此，理解ONOS子系统结构和事件分发处理机制对进一步深入了解ONOS是有很大帮助的。&lt;/p&gt;
    
    </summary>
    
      <category term="ONOS" scheme="http://yoursite.com/categories/ONOS/"/>
    
    
      <category term="ONOS" scheme="http://yoursite.com/tags/ONOS/"/>
    
      <category term="SubSystem" scheme="http://yoursite.com/tags/SubSystem/"/>
    
      <category term="子系统" scheme="http://yoursite.com/tags/%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Event" scheme="http://yoursite.com/tags/Event/"/>
    
      <category term="事件分发" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ONOS中的OpenFlow Channel状态机解析</title>
    <link href="http://yoursite.com/2016/12/10/ONOS%E4%B8%AD%E7%9A%84OpenFlow-Channel%E7%8A%B6%E6%80%81%E6%9C%BA%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/12/10/ONOS中的OpenFlow-Channel状态机解析/</id>
    <published>2016-12-10T06:57:50.000Z</published>
    <updated>2017-04-10T09:20:00.966Z</updated>
    
    <content type="html"><![CDATA[<p>ONOS使用OFChannelHandler类来处理交换机和控制器的信道连接，同时将switch message分发到合适的位置，代码在package org.onosproject.openflow.controller.impl中。</p>
<a id="more"></a>
<h1 id="1-OpenFlow状态机：ChanelState"><a href="#1-OpenFlow状态机：ChanelState" class="headerlink" title="1. OpenFlow状态机：ChanelState"></a>1. OpenFlow状态机：ChanelState</h1><p>在OFChannelHandler类中，最重要的就是一个ChanelState的枚举类了，枚举类中的各个枚举实例表示Channel所处的状态，用来描述OpenFlow状态机信息，在枚举类中添加了处理OpenFlow消息的方法，各个枚举实例也根据自身的状态重写了部分方法。</p>
<p>OpenFlow状态机共定义了8种状态(<strong>INIT, WAIT_HELLO, WAIT_FEATURES_REPLY, WAIT_PORT_DESC_REPLY, WAIT_CONFIG_REPLY,  WAIT_DESCRIPTION_STAT_REPLY, WAIT_SWITCH_DRIVER_SUB_HANDSHAKE, ACTIVE</strong>)，任何时候，Channel处于状态机中的任意一种状态。每个状态（枚举实例）都有一个默认初始化参数，其中false表示交换机握手没有成功，true表示交换机握手成功，枚举类的构造函数和获取交换机握手状态的代码块如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> handshakeComplete;</div><div class="line">ChannelState(<span class="keyword">boolean</span> handshakeComplete) &#123;</div><div class="line">    <span class="keyword">this</span>.handshakeComplete = handshakeComplete;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Is this a state in which the handshake has completed?</div><div class="line"> * <span class="doctag">@return</span> true if the handshake is complete</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHandshakeComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> handshakeComplete;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="2-OpenFlow状态机启动流程"><a href="#2-OpenFlow状态机启动流程" class="headerlink" title="2. OpenFlow状态机启动流程"></a>2. OpenFlow状态机启动流程</h1><p>ONOS使用netty通信框架（参考：<a href="https://waylau.gitbooks.io/essential-netty-in-action/content/GETTING%20STARTED/Building%20Blocks.html" target="_blank" rel="external">Netty 实战</a>），在这里就不考虑netty相关的NIO过程了。ONOS启动ChannelHander对应的实例时，构造函数OFChannelHandler(Controller controller) 会引用当前的控制器实例，同时会将<strong>stage</strong>初始化为ChannelState.INIT状态，表示Channel处于连接之前（代码注释很清楚）。注意，OFChannelHandler中的state变量是<strong>volatile</strong>类型，这是为了确保HandshakeTimeoutHandler检测到的state状态都是最新的，至于volatile关键字的用法，建议参考：<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">Java并发编程：volatile关键字解析</a></p>
<p>当Channel检测到交换机连接时，会调用OFChannelHandler类中的channelConnected函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelConnected</span><span class="params">(ChannelHandlerContext ctx,</span></span></div><div class="line">        ChannelStateEvent e) <span class="keyword">throws</span> Exception &#123;</div><div class="line">    channel = e.getChannel();</div><div class="line">    log.info(<span class="string">"New switch connection from &#123;&#125;"</span>,</div><div class="line">            channel.getRemoteAddress());</div><div class="line">    <span class="comment">/*</span></div><div class="line">        hack to wait for the switch to tell us what it's</div><div class="line">        max version is. This is not spec compliant and should</div><div class="line">        be removed as soon as switches behave better.</div><div class="line">     */</div><div class="line">    <span class="comment">//sendHandshakeHelloMessage();</span></div><div class="line">    setState(ChannelState.WAIT_HELLO);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，state被设置为ChannelState.WAIT_HELLO状态，顾名思义，就是等待交换机的hello消息了。当Channel得到交换机发往控制器的消息时，就会调用messageReceived函数，messageReceived又会调用<strong>当前状态机实例</strong>的processOFMessage方法，处理OFMessage消息，各种不同的OFMessage消息对应了不同的消息处理函数，在ChannelState枚举类中都有定义。<strong>需要注意的是，不同的状态机实例可能根据当前状态重写ChannelState中的消息处理函数，因此同一消息类型在不同的状态下的处理逻辑可能是不一样的</strong>。OFMessage处理完成后，调用setState方法来切换状态机，握手成功后，状态机处于ACTIVE(true)状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(ChannelHandlerContext ctx, MessageEvent e)</span></span></div><div class="line">        <span class="keyword">throws</span> Exception &#123;</div><div class="line">    <span class="keyword">if</span> (e.getMessage() <span class="keyword">instanceof</span> List) &#123;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        List&lt;OFMessage&gt; msglist = (List&lt;OFMessage&gt;) e.getMessage();</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (OFMessage ofm : msglist) &#123;</div><div class="line">            <span class="comment">// Do the actual packet processing</span></div><div class="line">            state.processOFMessage(<span class="keyword">this</span>, ofm);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        state.processOFMessage(<span class="keyword">this</span>, (OFMessage) e.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Process an OF message received on the channel and</div><div class="line"> * update state accordingly.</div><div class="line"> *</div><div class="line"> * The main "event" of the state machine. Process the received message,</div><div class="line"> * send follow up message if required and update state if required.</div><div class="line"> *</div><div class="line"> * Switches on the message type and calls more specific event handlers</div><div class="line"> * for each individual OF message type. If we receive a message that</div><div class="line"> * is supposed to be sent from a controller to a switch we throw</div><div class="line"> * a SwitchStateExeption.</div><div class="line"> *</div><div class="line"> * The more specific handlers can also throw SwitchStateExceptions</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> h The OFChannelHandler that received the message</div><div class="line"> * <span class="doctag">@param</span> m The message we received.</div><div class="line"> * <span class="doctag">@throws</span> SwitchStateException if the switch is not bound to the channel</div><div class="line"> * <span class="doctag">@throws</span> IOException if unable to send message back to the switch</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">processOFMessage</span><span class="params">(OFChannelHandler h, OFMessage m)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException, SwitchStateException &#123;</div><div class="line">    <span class="keyword">switch</span>(m.getType()) &#123;</div><div class="line">    <span class="keyword">case</span> HELLO:</div><div class="line">        processOFHello(h, (OFHello) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> BARRIER_REPLY:</div><div class="line">        processOFBarrierReply(h, (OFBarrierReply) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ECHO_REPLY:</div><div class="line">        processOFEchoReply(h, (OFEchoReply) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ECHO_REQUEST:</div><div class="line">        processOFEchoRequest(h, (OFEchoRequest) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ERROR:</div><div class="line">        processOFError(h, (OFErrorMsg) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> FEATURES_REPLY:</div><div class="line">        processOFFeaturesReply(h, (OFFeaturesReply) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> FLOW_REMOVED:</div><div class="line">        processOFFlowRemoved(h, (OFFlowRemoved) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> GET_CONFIG_REPLY:</div><div class="line">        processOFGetConfigReply(h, (OFGetConfigReply) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> PACKET_IN:</div><div class="line">        processOFPacketIn(h, (OFPacketIn) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> PORT_STATUS:</div><div class="line">        processOFPortStatus(h, (OFPortStatus) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> QUEUE_GET_CONFIG_REPLY:</div><div class="line">        processOFQueueGetConfigReply(h, (OFQueueGetConfigReply) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> STATS_REPLY: <span class="comment">// multipart_reply in 1.3</span></div><div class="line">        processOFStatisticsReply(h, (OFStatsReply) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> EXPERIMENTER:</div><div class="line">        processOFExperimenter(h, (OFExperimenter) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ROLE_REPLY:</div><div class="line">        processOFRoleReply(h, (OFRoleReply) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> GET_ASYNC_REPLY:</div><div class="line">        processOFGetAsyncReply(h, (OFAsyncGetReply) m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// The following messages are sent to switches. The controller</span></div><div class="line">        <span class="comment">// should never receive them</span></div><div class="line">    <span class="keyword">case</span> SET_CONFIG:</div><div class="line">    <span class="keyword">case</span> GET_CONFIG_REQUEST:</div><div class="line">    <span class="keyword">case</span> PACKET_OUT:</div><div class="line">    <span class="keyword">case</span> PORT_MOD:</div><div class="line">    <span class="keyword">case</span> QUEUE_GET_CONFIG_REQUEST:</div><div class="line">    <span class="keyword">case</span> BARRIER_REQUEST:</div><div class="line">    <span class="keyword">case</span> STATS_REQUEST: <span class="comment">// multipart request in 1.3</span></div><div class="line">    <span class="keyword">case</span> FEATURES_REQUEST:</div><div class="line">    <span class="keyword">case</span> FLOW_MOD:</div><div class="line">    <span class="keyword">case</span> GROUP_MOD:</div><div class="line">    <span class="keyword">case</span> TABLE_MOD:</div><div class="line">    <span class="keyword">case</span> GET_ASYNC_REQUEST:</div><div class="line">    <span class="keyword">case</span> SET_ASYNC:</div><div class="line">    <span class="keyword">case</span> METER_MOD:</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        illegalMessageReceived(h, m);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是状态机启动的基本流程了，更详细的过程看OFChannelHandler源码。</p>
<p>参考：</p>
<p><a href="http://kailongli.github.io/channel-state" target="_blank" rel="external">ONOS中Channel状态机分析</a></p>
<p><a href="http://kailongli.github.io/switch-connection" target="_blank" rel="external">ONOS中控制器与交换机建立连接的过程</a></p>
<p><a href="http://flowgrammable.org/sdn/openflow/state-machine/" target="_blank" rel="external">OpenFlow state machine</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ONOS使用OFChannelHandler类来处理交换机和控制器的信道连接，同时将switch message分发到合适的位置，代码在package org.onosproject.openflow.controller.impl中。&lt;/p&gt;
    
    </summary>
    
      <category term="ONOS" scheme="http://yoursite.com/categories/ONOS/"/>
    
    
      <category term="ONOS" scheme="http://yoursite.com/tags/ONOS/"/>
    
  </entry>
  
  <entry>
    <title>OSGi简介与基于OSGi框架（Felix）的简单应用实现</title>
    <link href="http://yoursite.com/2016/12/08/OSGi%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E4%BA%8EOSGi%E6%A1%86%E6%9E%B6%EF%BC%88Felix%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2016/12/08/OSGi简介与基于OSGi框架（Felix）的简单应用的实现/</id>
    <published>2016-12-08T07:50:04.000Z</published>
    <updated>2017-03-20T06:56:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>OSGi(Open Service Gateway Initiative)，其英文定义为：The Dynamic Module System for Java。由此可见，OSGi的主要职责就是为了让开发者能够构建动态化、模块化的Java系统。使用OSGi，系统的各个组件就像插件一样，暴露特定的接口，实现“即插即用”。</p>
<a id="more"></a>
<h1 id="1-OSGi的基本概念"><a href="#1-OSGi的基本概念" class="headerlink" title="1. OSGi的基本概念"></a>1. OSGi的基本概念</h1><h2 id="1-1-bundle"><a href="#1-1-bundle" class="headerlink" title="1.1 bundle"></a>1.1 bundle</h2><p>在OSGi中，各个组件以bundle的形式存在，但从形式上讲，bundle也就是在META-INF目录下的MANIFEST.MF文件中加入了OSGi特定描述的jar包。bundle的生命周期被OSGi框架所管理，具有如下几个状态：INSTALLED, RESOLVED,STARTING, ACTIVE, STOPPING,  UNINSTALLED。bundle各个生命周期状态的转换如下图所示：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/bundle.png" alt=""></p>
<p>bundle通过配置jar包中的MANIFEST.MF文件控制从bundle导出的包。而没有导出的包在bundle外部不能使用，这样就很好的完成了内部类和外部类的隔离。bundle可以被动态的安装、启动、停止和卸载。bundle是服务（Service）和组件（Component）的载体。事实上，不管是通过BundleContext注册和获取服务的方式，还是Declarative Service进行声明注入的方式，都是在编写bundle。</p>
<p>在OSGi中，每个bundle都有独立于其它bundle的ClassLoader，正因为这样，各个bundle的类是相互隔离的。但一个bundle可能会用到另外一个bundle的类，bundle之间的交户通过以下三种方式实现：</p>
<ul>
<li><p>Export-Package：根据OSGi规范，每个工程可以通过声明Export-Package对外提供访问此工程中的类和接口，可以先把bundle导出，再导入到需要调用的bundle中，默认情况下一个bundle中所有的Package对外都是不可见的。</p>
</li>
<li><p>OSGi服务：通过将要对外提供功能声明为OSGi的服务实现面向接口、面向服务式的设计。一个bundle作为Service的提供方，对外提供Service，使用者可以查找到提供的Service。提供使用Service有三种方式：</p>
<ul>
<li>通过BundleContext（bundle的上下文）来提供和获取；</li>
<li>使用Declarative Service来获取；</li>
<li>使用Blueprint来获取；</li>
</ul>
</li>
<li><p>Event：OSGi的Event服务也是实现模块交互的一种可选方法，模块对外发布事件，订阅了此事件的模块就会相应地接收到消息，从而做出反应，以达到交互的目的。</p>
</li>
</ul>
<h2 id="1-2-OSGi-Service"><a href="#1-2-OSGi-Service" class="headerlink" title="1.2 OSGi Service"></a>1.2 OSGi Service</h2><p> 一个OSGi Service就是注册到OSGi框架中的Java对象的引用。在注册的时候可以设置这个Service的属性，从而在获取Service的时候可以进行过滤。OSGi拥有一个集中的服务注册中心，它遵循<strong>发布-查询-绑定</strong>模型，如下图所示。</p>
<p> <img src="http://oj37kd49l.bkt.clouddn.com/osgi-service-registry.jpg" alt=""></p>
<p> bundle可以通过bundle的上下文去注册Service或去查询Service，获取对应服务的对象引用。当然还有其它方式实现OSGi Service，就是上面提到的声明式服务和Blueprint服务。关于OSGi Service使用方式的选择问题，参考：</p>
<p> <a href="http://www.infoq.com/cn/news/2013/12/osgi-blueprint-or-ds" target="_blank" rel="external">OSGi中该使用Blueprint还是声明式服务?</a></p>
<p> 后面的例子将介绍使用BundleContext注册和获取OSGi Service。</p>
<h2 id="1-3-OSGi框架"><a href="#1-3-OSGi框架" class="headerlink" title="1.3 OSGi框架"></a>1.3 OSGi框架</h2><p>OSGi框架可以看做实现了OSGi规范的容器，使用OSGi框架，可以实现各种bundle的“即插即用”，目前流行的框架包括Equinox和Felix，下面的简单应用是基于Felix框架实现的。</p>
<h1 id="2-基于OSGi框架（Felix）简单应用的实现"><a href="#2-基于OSGi框架（Felix）简单应用的实现" class="headerlink" title="2. 基于OSGi框架（Felix）简单应用的实现"></a>2. 基于OSGi框架（Felix）简单应用的实现</h1><p>下面将介绍使用Maven工具和Felix框架实现OSGi简单应用，源码链接：</p>
<ul>
<li><a href="https://github.com/baymaxhuang/osgi-provider" target="_blank" rel="external">osgi-provider</a></li>
<li><a href="https://github.com/baymaxhuang/osgi-consumer" target="_blank" rel="external">osgi-consumer</a></li>
</ul>
<h2 id="2-1-使用BundleContext注册和获取OSGi-Service"><a href="#2-1-使用BundleContext注册和获取OSGi-Service" class="headerlink" title="2.1 使用BundleContext注册和获取OSGi Service"></a>2.1 使用BundleContext注册和获取OSGi Service</h2><p>使用两个bundle分别实现服务的注册和获取，由服务提供者（Service Provider）注册OSGi服务，服务消费者（Service Consumer）获取服务，Service Provider使用接口提供服务，而Service Consumer也将使用接口获取对应服务的实例化对象。</p>
<h3 id="2-1-1-定义服务并注册"><a href="#2-1-1-定义服务并注册" class="headerlink" title="2.1.1 定义服务并注册"></a>2.1.1 定义服务并注册</h3><ul>
<li><p>定义服务接口HelloWorldService</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">package org.hhb.osgi.provider.api;</div><div class="line"></div><div class="line">public interface HelloWorldService &#123;</div><div class="line">    public void hello();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现服务HelloWorldServiceImpl</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package org.hhb.osgi.provider.impl;</div><div class="line"></div><div class="line">import org.hhb.osgi.provider.api.HelloWorldService;</div><div class="line"></div><div class="line">public class HelloWorldServiceImpl implements HelloWorldService &#123;</div><div class="line">    @Override</div><div class="line">    public void hello()&#123;</div><div class="line">        System.out.println(&quot;Hello World !&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现BundleActivator接口注册服务并实例化服务对象</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package org.hhb.osgi.provider;</div><div class="line"></div><div class="line">import org.hhb.osgi.provider.api.HelloWorldService;</div><div class="line">import org.hhb.osgi.provider.impl.HelloWorldServiceImpl;</div><div class="line">import org.osgi.framework.BundleActivator;</div><div class="line">import org.osgi.framework.BundleContext;</div><div class="line">import org.osgi.framework.ServiceRegistration;</div><div class="line"></div><div class="line">public class HelloActivator implements BundleActivator &#123;</div><div class="line">    private ServiceRegistration registration;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void start(BundleContext bundleContext) throws Exception &#123;</div><div class="line">        registration = bundleContext.registerService(</div><div class="line">                HelloWorldService.class.getName(),</div><div class="line">                new HelloWorldServiceImpl(),</div><div class="line">                null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void stop(BundleContext bundleContext) throws Exception &#123;</div><div class="line">        registration.unregister();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  需要注意的是，上面的start和stop方法将分别在bundle start和stop时被调用。</p>
</li>
<li><p>使用maven-bundle-plugin插件打包bundle</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</div><div class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">    &lt;groupId&gt;org.hhb&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;osgi-provider&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">    &lt;packaging&gt;bundle&lt;/packaging&gt;</div><div class="line"></div><div class="line">    &lt;build&gt;</div><div class="line">        &lt;plugins&gt;</div><div class="line">            &lt;plugin&gt;</div><div class="line">                &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;maven-bundle-plugin&lt;/artifactId&gt;</div><div class="line">                &lt;version&gt;2.4.0&lt;/version&gt;</div><div class="line">                &lt;extensions&gt;true&lt;/extensions&gt;</div><div class="line"></div><div class="line">                &lt;configuration&gt;</div><div class="line">                    &lt;instructions&gt;</div><div class="line">                        &lt;Bundle-SymbolicName&gt;$&#123;pom.groupId&#125;.$&#123;pom.artifactId&#125;&lt;/Bundle-SymbolicName&gt;</div><div class="line">                        &lt;Bundle-Vendor&gt;Apache Felix&lt;/Bundle-Vendor&gt;</div><div class="line">                        &lt;Bundle-Activator&gt;org.hhb.osgi.provider.HelloActivator&lt;/Bundle-Activator&gt;</div><div class="line">                    &lt;/instructions&gt;</div><div class="line">                &lt;/configuration&gt;</div><div class="line">            &lt;/plugin&gt;</div><div class="line">            &lt;plugin&gt;</div><div class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</div><div class="line">                &lt;configuration&gt;</div><div class="line">                    &lt;source&gt;1.8&lt;/source&gt;</div><div class="line">                    &lt;target&gt;1.8&lt;/target&gt;</div><div class="line">                &lt;/configuration&gt;</div><div class="line">            &lt;/plugin&gt;</div><div class="line"></div><div class="line">        &lt;/plugins&gt;</div><div class="line">    &lt;/build&gt;</div><div class="line"></div><div class="line">    &lt;dependencies&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;org.osgi.core&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;1.4.0&lt;/version&gt;</div><div class="line">            &lt;scope&gt;provided&lt;/scope&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">    &lt;/dependencies&gt;</div><div class="line"></div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<p>  这样编译打包后，就会在jar包下的META-INF文件夹下生成一个描述bundle信息的MANIFEST.MF文件。</p>
</li>
</ul>
<h3 id="2-1-2-获取并使用服务"><a href="#2-1-2-获取并使用服务" class="headerlink" title="2.1.2 获取并使用服务"></a>2.1.2 获取并使用服务</h3><ul>
<li><p>定义服务消费类HelloWorldConsumer</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package org.hhb.osgi.consumer;</div><div class="line"></div><div class="line">import javax.swing.Timer;</div><div class="line"></div><div class="line">import java.awt.event.ActionEvent;</div><div class="line">import java.awt.event.ActionListener;</div><div class="line"></div><div class="line">import org.hhb.osgi.provider.api.HelloWorldService;</div><div class="line"></div><div class="line">public class HelloWorldConsumer implements ActionListener &#123;</div><div class="line">    private final HelloWorldService service;</div><div class="line">    private final Timer timer;</div><div class="line"></div><div class="line">    public HelloWorldConsumer(HelloWorldService service) &#123;</div><div class="line">        super();</div><div class="line"></div><div class="line">        this.service = service;</div><div class="line"></div><div class="line">        timer = new Timer(1000, this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void startTimer()&#123;</div><div class="line">        timer.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void stopTimer() &#123;</div><div class="line">        timer.stop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void actionPerformed(ActionEvent e) &#123;</div><div class="line">        service.hello();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用BundleContext获取服务并使用</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package org.hhb.osgi.consumer;</div><div class="line"></div><div class="line">import org.osgi.framework.BundleActivator;</div><div class="line">import org.osgi.framework.BundleContext;</div><div class="line">import org.osgi.framework.ServiceReference;</div><div class="line"></div><div class="line">import org.hhb.osgi.provider.api.HelloWorldService;</div><div class="line"></div><div class="line">public class HelloWorldActivator implements BundleActivator &#123;</div><div class="line">    private HelloWorldConsumer consumer;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void start(BundleContext bundleContext) throws Exception &#123;</div><div class="line">        ServiceReference reference = bundleContext.getServiceReference(HelloWorldService.class.getName());</div><div class="line"></div><div class="line">        consumer = new HelloWorldConsumer((HelloWorldService) bundleContext.getService(reference));</div><div class="line">        consumer.startTimer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void stop(BundleContext bundleContext) throws Exception &#123;</div><div class="line">        consumer.stopTimer();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>pom文件配置</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">  &lt;groupId&gt;org.hhb&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;osgi-consumer&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">  &lt;packaging&gt;bundle&lt;/packaging&gt;</div><div class="line"></div><div class="line">  &lt;name&gt;osgi-consumer&lt;/name&gt;</div><div class="line">  &lt;url&gt;http://maven.apache.org&lt;/url&gt;</div><div class="line"></div><div class="line">  &lt;properties&gt;</div><div class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">  &lt;/properties&gt;</div><div class="line"></div><div class="line">  &lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;org.osgi.core&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;1.4.0&lt;/version&gt;</div><div class="line">      &lt;scope&gt;provided&lt;/scope&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line"></div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;3.8.1&lt;/version&gt;</div><div class="line">      &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line"></div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;org.hhb&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;osgi-provider&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">  &lt;/dependencies&gt;</div><div class="line"></div><div class="line">  &lt;build&gt;</div><div class="line">    &lt;plugins&gt;</div><div class="line">      &lt;plugin&gt;</div><div class="line">        &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;maven-bundle-plugin&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;2.4.0&lt;/version&gt;</div><div class="line">        &lt;extensions&gt;true&lt;/extensions&gt;</div><div class="line"></div><div class="line">        &lt;configuration&gt;</div><div class="line">          &lt;instructions&gt;</div><div class="line">            &lt;Bundle-SymbolicName&gt;$&#123;pom.groupId&#125;.$&#123;pom.artifactId&#125;&lt;/Bundle-SymbolicName&gt;</div><div class="line">            &lt;Bundle-Vendor&gt;Apache Felix&lt;/Bundle-Vendor&gt;</div><div class="line">            &lt;Bundle-Activator&gt;org.hhb.osgi.consumer.HelloWorldActivator&lt;/Bundle-Activator&gt;</div><div class="line">          &lt;/instructions&gt;</div><div class="line">        &lt;/configuration&gt;</div><div class="line">      &lt;/plugin&gt;</div><div class="line">      &lt;plugin&gt;</div><div class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</div><div class="line">        &lt;configuration&gt;</div><div class="line">          &lt;source&gt;1.8&lt;/source&gt;</div><div class="line">          &lt;target&gt;1.8&lt;/target&gt;</div><div class="line">        &lt;/configuration&gt;</div><div class="line">      &lt;/plugin&gt;</div><div class="line"></div><div class="line">    &lt;/plugins&gt;</div><div class="line">  &lt;/build&gt;</div><div class="line"></div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-1-3-在Felix中运行服务"><a href="#2-1-3-在Felix中运行服务" class="headerlink" title="2.1.3 在Felix中运行服务"></a>2.1.3 在Felix中运行服务</h3><ul>
<li>下载<a href="http://felix.apache.org/downloads.cgi" target="_blank" rel="external">Felix Framework Distribution</a></li>
<li><p>运行Felix</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$java -jar bin/felex.jar</div><div class="line">____________________________</div><div class="line">Welcome to Apache Felix Gogo</div><div class="line"></div><div class="line">g!</div></pre></td></tr></table></figure>
</li>
<li><p>运行bundle</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">g!                                                                                                                         </div><div class="line">g! install file:../osgi/osgi-provider-1.0-SNAPSHOT.jar                                                                              11:01:54 </div><div class="line">bundle ID: 8</div><div class="line">g! start 8                                                                                                                          11:02:02 </div><div class="line">g! install file:../osgi/osgi-consumer-1.0-SNAPSHOT.jar                                                                              11:02:08 </div><div class="line">bundle ID: 9</div><div class="line">g! start 9                                                                                                                          11:02:16 </div><div class="line">g! Hello World !                                                                                                                    11:02:19 </div><div class="line">Hello World !</div><div class="line">Hello World !</div><div class="line">Hello World !</div><div class="line">Hello World !</div><div class="line">stop 9</div></pre></td></tr></table></figure>
<p>  其中file:../osgi/osgi-consumer-1.0-SNAPSHOT.jar表示bundle文件的路径。</p>
</li>
</ul>
<h2 id="2-2-使用Export-Package提供Package给其它bundle使用"><a href="#2-2-使用Export-Package提供Package给其它bundle使用" class="headerlink" title="2.2 使用Export-Package提供Package给其它bundle使用"></a>2.2 使用Export-Package提供Package给其它bundle使用</h2><p>很多情况下在bundle使用第三方库，如Guava，Netty时，并不希望以服务的方式获取，而希望使用Import Package就可以获取对应的包。而默认情况下，不同bundle中的包是相互隔离的，这时就需要使用Export-Package导出bundle中的包给其它bundle使用。</p>
<h3 id="2-2-1-产生bundle并Export-Package"><a href="#2-2-1-产生bundle并Export-Package" class="headerlink" title="2.2.1 产生bundle并Export Package"></a>2.2.1 产生bundle并Export Package</h3><ul>
<li>定义接口HelloWorldService（同上）</li>
</ul>
<ul>
<li>接口实现类HelloWorldServiceImpl（同上）</li>
</ul>
<ul>
<li><p>配置pom</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</div><div class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">    &lt;groupId&gt;org.hhb&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;osgi-provider&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">    &lt;packaging&gt;bundle&lt;/packaging&gt;</div><div class="line"></div><div class="line">    &lt;build&gt;</div><div class="line">        &lt;plugins&gt;</div><div class="line">            &lt;plugin&gt;</div><div class="line">                &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;maven-bundle-plugin&lt;/artifactId&gt;</div><div class="line">                &lt;version&gt;2.4.0&lt;/version&gt;</div><div class="line">                &lt;extensions&gt;true&lt;/extensions&gt;</div><div class="line"></div><div class="line">                &lt;configuration&gt;</div><div class="line">                    &lt;instructions&gt;</div><div class="line">                        &lt;Bundle-SymbolicName&gt;$&#123;pom.groupId&#125;.$&#123;pom.artifactId&#125;&lt;/Bundle-SymbolicName&gt;</div><div class="line">                        &lt;Bundle-Vendor&gt;Apache Felix&lt;/Bundle-Vendor&gt;</div><div class="line">                        &lt;Export-Package&gt;org.hhb.osgi.provider.api, org.hhb.osgi.provider.impl&lt;/Export-Package&gt;</div><div class="line">                    &lt;/instructions&gt;</div><div class="line">                &lt;/configuration&gt;</div><div class="line">            &lt;/plugin&gt;</div><div class="line">            &lt;plugin&gt;</div><div class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</div><div class="line">                &lt;configuration&gt;</div><div class="line">                    &lt;source&gt;1.8&lt;/source&gt;</div><div class="line">                    &lt;target&gt;1.8&lt;/target&gt;</div><div class="line">                &lt;/configuration&gt;</div><div class="line">            &lt;/plugin&gt;</div><div class="line"></div><div class="line">        &lt;/plugins&gt;</div><div class="line">    &lt;/build&gt;</div><div class="line"></div><div class="line">    &lt;dependencies&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;org.osgi.core&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;1.4.0&lt;/version&gt;</div><div class="line">            &lt;scope&gt;provided&lt;/scope&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">    &lt;/dependencies&gt;</div><div class="line"></div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<p>  需要注意的是，激活器（bundle-Activator）对一个bundle来说不是必需的，也就是说，bundle的start过程并处于Active状态并不需要bundle-Activator。只有当构建一个bundle，并需要与OSGi API进行交换时，或者需要执行自定义的初始化/销毁动作，激活器才是必须的。事实上，前面使用bundle-Activator主要是为了注册服务并实例化服务对象，这样其它bundle就可以直接使用该服务了。</p>
</li>
</ul>
<h3 id="2-2-2-在另一bundle种使用外部包"><a href="#2-2-2-在另一bundle种使用外部包" class="headerlink" title="2.2.2 在另一bundle种使用外部包"></a>2.2.2 在另一bundle种使用外部包</h3><ul>
<li><p>定义服务消费类HelloWorldConsumer（同上）</p>
</li>
<li><p>Import Package并使用</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package org.hhb.osgi.consumer;</div><div class="line"></div><div class="line">import com.google.common.collect.Lists;</div><div class="line">import org.osgi.framework.BundleActivator;</div><div class="line">import org.osgi.framework.BundleContext;</div><div class="line">import org.hhb.osgi.provider.impl.HelloWorldServiceImpl;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class HelloWorldActivator implements BundleActivator &#123;</div><div class="line">    private HelloWorldConsumer consumer;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void start(BundleContext bundleContext) throws Exception &#123;</div><div class="line">        //test for using third-party dependency package</div><div class="line">        List&lt;String&gt; strings = Lists.newArrayList(&quot;I&quot;, &quot;use&quot;, &quot;guava&quot;, &quot;here&quot;);</div><div class="line">        System.out.println(strings);</div><div class="line"></div><div class="line">        //test for using my customized dependency package</div><div class="line">        //ServiceReference reference = bundleContext.getServiceReference(HelloWorldService.class.getName());</div><div class="line">        consumer = new HelloWorldConsumer(new HelloWorldServiceImpl());</div><div class="line">        consumer.startTimer();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void stop(BundleContext bundleContext) throws Exception &#123;</div><div class="line">        consumer.stopTimer();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>pom的配置（同上）</p>
<p>  需要注意的是，maven-bundle-plugin会根据类中声明的import的包信息导入所有的Package并写入MANIFEST-MF文件的Import-Package字段中，若自己在pom中定义Import-Package信息，需要注意不要遗漏相关的Package。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">    &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;maven-bundle-plugin&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;2.4.0&lt;/version&gt;</div><div class="line">    &lt;extensions&gt;true&lt;/extensions&gt;</div><div class="line"></div><div class="line">    &lt;configuration&gt;</div><div class="line">      &lt;instructions&gt;</div><div class="line">        &lt;Bundle-SymbolicName&gt;$&#123;pom.groupId&#125;.$&#123;pom.artifactId&#125;&lt;/Bundle-SymbolicName&gt;</div><div class="line">        &lt;Bundle-Vendor&gt;Apache Felix&lt;/Bundle-Vendor&gt;</div><div class="line">        &lt;Bundle-Activator&gt;org.hhb.osgi.consumer.HelloWorldActivator&lt;/Bundle-Activator&gt;</div><div class="line">        &lt;!--&lt;Import-Package&gt;com.google.common.collect,javax.swing,org.osgi.framework,</div><div class="line">        org.hhb.osgi.provider.api,org.hhb.osgi.provider.impl&lt;/Import-Package&gt;--&gt;</div><div class="line">      &lt;/instructions&gt;</div><div class="line">    &lt;/configuration&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-3-在Felix中运行服务"><a href="#2-2-3-在Felix中运行服务" class="headerlink" title="2.2.3 在Felix中运行服务"></a>2.2.3 在Felix中运行服务</h3><p> 同上</p>
<h3 id="2-2-4-bundle中使用外部包总结"><a href="#2-2-4-bundle中使用外部包总结" class="headerlink" title="2.2.4 bundle中使用外部包总结"></a>2.2.4 bundle中使用外部包总结</h3><p>在Java程序中，用到外部包中的类几乎是必然的事情，在OSGI和MAVEN环境下，引用外部包的方法总结如下：</p>
<ol>
<li><p>java.开头的包，是JDK提供了，代码中直接import。</p>
</li>
<li><p>org.osgi开头的（包括core、compendium等），是osgi规范提供的，已经包含在osgi框架（Felix）中，开发时需要导入，但是发布程序中不需要包含，由Felix提供，实现方法是添加scope为provided的maven依赖，如：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;org.osgi.core&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.4.0&lt;/version&gt;</div><div class="line">    &lt;scope&gt;provided&lt;/scope&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>第三方jar包，可能有多个bundle共享的，直接osgi化，然后作为独立bundle安装到Felix中,如Guava，部署时只要将这些包作为一个独立的bundle并启动，其他bundle就可以通过直接Import-Package的方式来引用这些包。之所以能够这么做是因为这个jar已经osgi化了，查看jar包中的META-INF/MENIFEST.MF文件，可以看到这些jar包Export的包信息。</p>
</li>
<li>第三方的jar包，不考虑多个bundle共享，只确保一个bundle的独立依赖，可以把这些依赖的jar嵌入到开发的bundle中发布。maven中加入这些jar包的dependency的依赖项就可以在开发时引用了，但是发布到Felix框架时，我们要把这些jar包一起提供才行，方法是把这些jar包嵌入到我们的bundle中，使用maven-bundle-plugin，增加instructions配置<embed-dependency>*;scope=compile|runtime</embed-dependency>，这样maven在打包是就可以自动把这些依赖的jar包嵌入。要注意这些依赖的scope和Embed-Dependency的表述方式的匹配，具体Embed-Dependency可能的写法请参见<a href="http://felix.apache.org/documentation/subprojects/apache-felix-maven-bundle-plugin-bnd.html" target="_blank" rel="external">maven-bundle-plugin</a>在线文档。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OSGi(Open Service Gateway Initiative)，其英文定义为：The Dynamic Module System for Java。由此可见，OSGi的主要职责就是为了让开发者能够构建动态化、模块化的Java系统。使用OSGi，系统的各个组件就像插件一样，暴露特定的接口，实现“即插即用”。&lt;/p&gt;
    
    </summary>
    
      <category term="OSGi" scheme="http://yoursite.com/categories/OSGi/"/>
    
    
      <category term="OSGi" scheme="http://yoursite.com/tags/OSGi/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Felix" scheme="http://yoursite.com/tags/Felix/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java：抽象类和接口</title>
    <link href="http://yoursite.com/2016/12/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2016/12/06/深入理解Java：抽象类和接口/</id>
    <published>2016-12-06T03:01:58.000Z</published>
    <updated>2017-09-18T01:32:50.837Z</updated>
    
    <content type="html"><![CDATA[<p>抽象类和接口是Java中的重要类型，对Java实现灵活的继承和多态有极其重要的作用。关于抽象类和接口的用法教程有很多，本篇文章主要用来记录Java中抽象类和接口的一些重要的概念和特殊的用法，从而加深对抽象类和接口的理解。</p>
<a id="more"></a>
<h1 id="1-关于抽象类"><a href="#1-关于抽象类" class="headerlink" title="1. 关于抽象类"></a>1. 关于抽象类</h1><p>抽象类可以不包含抽象方法，在这种情况下，这种类是用来定义子类的基类，这也是抽象类最常用的一种方式。抽象类的抽象方法不能在抽象类中实现，当子类继承一个抽象类时，该子类要么实现父类的所有抽象方法，要么将该子类定义为一个抽象类。虽然不能根据抽象类new一个对象实例，但抽象类也有构造方法，包括默认的和自定义的构造方法，当子类继承抽象类并生成一个对象时，会先调用抽象类的构造方法。</p>
<h1 id="2-关于接口"><a href="#2-关于接口" class="headerlink" title="2. 关于接口"></a>2. 关于接口</h1><h2 id="2-1-接口的定义和声明"><a href="#2-1-接口的定义和声明" class="headerlink" title="2.1 接口的定义和声明"></a>2.1 接口的定义和声明</h2><p>由于接口中所有的数据域都是public、static、final，而且所有的方法都是public abstract，所以Java允许忽略这些修饰符。因此下面的接口是等价的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> k = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口中不能包含方法的实现，下面定义的接口类型是错误的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</div><div class="line">    <span class="comment">//接口中所有的方法都是public abstract，抽象方法不能在抽象类中实现</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但要注意的是继承该接口的子类实现接口的方法时要明确指明该方法的访问权限是public，不能是默认访问权限或其它访问权限，下面的是错误的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"m1"</span> + k);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"class B"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">         B c = <span class="keyword">new</span> B();</div><div class="line">         System.out.println(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正确的接口继承方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"m1"</span> + k);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"class B"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">         B c = <span class="keyword">new</span> B();</div><div class="line">         System.out.println(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-2-使用接口声明对象的引用"><a href="#2-2-使用接口声明对象的引用" class="headerlink" title="2.2 使用接口声明对象的引用"></a>2.2 使用接口声明对象的引用</h2><p>使用接口声明一个对象的引用时，实际上是将该对象向上转型为对应的接口类型，这样可以方便我们编写代码时与接口打交道，而不用考虑具体的实现。例如，可以使用List声明一个指向ArrayList对象的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</div></pre></td></tr></table></figure>
<p>在这里，ArrayList已经向上转型为List，这样声明可以方便我们想要修改实现的时候，只需在创建时修改它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> LinkedList&lt;&gt;();</div></pre></td></tr></table></figure>
<p>因此，在创建一个具体对象时，应多考虑将其转型为一个对应的接口，然后在其余的代码中使用这个接口。这也呼应了Java编程中的“针对接口编程”的思想了。</p>
<p><strong>注意：</strong> 由于一个类可以实现多个接口，接口也可以继承，因此可以通的接口类型声明一个对象的引用。而对象的属性是由类本身决定的，因此对该对象的本身来说，没有本质的差异。但由于引用可访问的方法是和声明的接口类型是相关的，因此不同的声明方式对使用者来说有区别的。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ConcurrentMap&lt;Integer,Group&gt; groupMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Integer, Group&gt;();</div><div class="line"><span class="keyword">private</span> Map&lt;Integer,Group&gt; groupMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Integer, Group&gt;();</div></pre></td></tr></table></figure>
<p>这两种声明方式都可以引用一个线程安全的map，但若需要调用ConcurrentHashMap的putIfAbsent方法来保证map里面有且只有一个特定的资源，这种时候，就应该声明为ConcurrentHashMap，表明代码语义是跟一个支持同步语义的map进行交流，而不是一个普通的一般性的map。即使这样，两种声明方式在使用putIfAbsent时没有本质区别，这是因为最终调用的还是ConcurrentHashMap中实现的putIfAbsent方法，是线程安全的。</p>
<p>参考：</p>
<p><a href="https://www.zhihu.com/question/27929932" target="_blank" rel="external">知乎：使用不同的接口声明对象引用</a></p>
<h2 id="2-3-接口与匿名类"><a href="#2-3-接口与匿名类" class="headerlink" title="2.3 接口与匿名类"></a>2.3 接口与匿名类</h2><p>接口不可以new，但可以用new产生一个实现接口的匿名类。<br>如Swing中常用到的new ActionListener() {  } ，就是在{}中重写ActionListen接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">button2.addActionListener (  </div><div class="line">    <span class="keyword">new</span> ActionListener() &#123;  </div><div class="line">        <span class="function">publicvoid <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;  </div><div class="line">            System.out.println(<span class="string">"你按了按钮"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="2-4-函数式接口"><a href="#2-4-函数式接口" class="headerlink" title="2.4 函数式接口"></a>2.4 函数式接口</h2><p>当一个接口只有一个抽象方法时，这个接口就是函数式接口，函数式接口用作lambda表达式的类型。详细内容请参考：<br><a href="https://baymaxhuang.github.io/2016/12/04/java-8-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="external">Java 8 新特性：lambda表达式</a></p>
<h2 id="2-5-Java-8接口中的默认方法"><a href="#2-5-Java-8接口中的默认方法" class="headerlink" title="2.5 Java 8接口中的默认方法"></a>2.5 Java 8接口中的默认方法</h2><p>Java 8中接口可以实现方法，而不需要实现类去实现方法，通过在接口方法中加入关键字default，就可以在接口中实现方法了。</p>
<p>为什么要有这个特性？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p>
<p>引入接口的默认方法后，接口和抽象类有了更多的相同点了，但二者依然有区别，下面是Java 8抽象类和接口的对比：</p>
<p><strong>相同点：</strong> </p>
<ol>
<li>都是抽象类型；</li>
<li>都可以有实现方法（以前接口不行）；</li>
<li>都可以不需要实现类或者继承者去实现所有方法，（以前不行，现在接口中默认方法不需要实现者实现） </li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）；</li>
<li>抽象类和接口所反映出的设计理念不同。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系；</li>
<li>接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。 </li>
</ol>
<p><strong>注意：</strong> 若在实现类中实现了接口的默认方法，则最终会调用实现类的方法；若子接口覆盖了父接口的默认方法，则会调用子接口的默认方法；若子接口声明了和父接口一样的方法但没有实现，那么无论该方法是不是父接口的默认方法，在实现类中都要实现。看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Calling A.test()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Calling B.foo()"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</div><div class="line">    <span class="comment">//test() must be implemented in this class</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Calling C.test()"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        A obj = <span class="keyword">new</span> C();</div><div class="line">        obj.foo();<span class="comment">//Calling B.foo()</span></div><div class="line">        obj.test();<span class="comment">//Calling C.test()</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于接口的默认方法在Java 8的JDK库中有很多使用，可以参照Map，ConcurrentMap，ConcurrentHashMap学习接口的默认方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抽象类和接口是Java中的重要类型，对Java实现灵活的继承和多态有极其重要的作用。关于抽象类和接口的用法教程有很多，本篇文章主要用来记录Java中抽象类和接口的一些重要的概念和特殊的用法，从而加深对抽象类和接口的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 8新特性：流式处理</title>
    <link href="http://yoursite.com/2016/12/04/Java-8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2016/12/04/Java-8新特性：流式处理/</id>
    <published>2016-12-04T04:46:51.000Z</published>
    <updated>2017-04-09T01:33:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>声明：本篇博客很多内容引用自<a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="external">Java 8 中的 Streams API 详解</a>和<a href="http://www.ituring.com.cn/book/1448" target="_blank" rel="external">Java 8函数式编程</a>，同时文中也有很多自己的理解和学习体会，希望通过这篇文章深入的介绍和总结Java 8的流式处理。</p>
<a id="more"></a>
<h1 id="1-什么是流"><a href="#1-什么是流" class="headerlink" title="1. 什么是流"></a>1. 什么是流</h1><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>
<p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>
<p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p>
<ul>
<li>1.0-1.4 中的 java.lang.Thread</li>
<li>5.0 中的 java.util.concurrent</li>
<li>6.0 中的 Phasers 等</li>
<li>7.0 中的 Fork/Join 框架</li>
<li>8.0 中的 Lambda</li>
</ul>
<p>Stream 的另外一大特点是，数据源本身可以是无限的。</p>
<p><strong>总的来说，Stream是用函数编程的方式在集合类上进行复杂操作的工具。</strong></p>
<h1 id="2-流的构成"><a href="#2-流的构成" class="headerlink" title="2. 流的构成"></a>2. 流的构成</h1><p>当我们使用一个流的时候，通常包括三个基本步骤：</p>
<p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/Java%208%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AStream-1.png" alt=""></p>
<p>流的操作类型分为两种：</p>
<ul>
<li><p><strong>Intermediate</strong>：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p>
</li>
<li><p><strong>Terminal</strong>：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p>
</li>
</ul>
<p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p>
<p>例如，下面的Stream没有Terminal操作，不会输出任何信息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">5</span>);</div><div class="line">nums.stream()</div><div class="line">        .filter(num -&gt; &#123;</div><div class="line">            System.out.println(num);</div><div class="line">            <span class="keyword">return</span> num != <span class="keyword">null</span>;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>使用Terminal操作后，所有的中间惰性操作才会执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="number">5</span>);</div><div class="line">nums.stream()</div><div class="line">        .filter(num -&gt; &#123;</div><div class="line">            System.out.println(num);</div><div class="line">            <span class="keyword">return</span> num != <span class="keyword">null</span>;</div><div class="line">        &#125;)</div><div class="line">        .count();</div></pre></td></tr></table></figure>
<p>上面代码打印的信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">null</div><div class="line">3</div><div class="line">4</div><div class="line">null</div><div class="line">5</div></pre></td></tr></table></figure>
<p>还有一种操作被称为 short-circuiting。指的是：</p>
<ul>
<li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li>
<li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li>
<li>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</li>
</ul>
<h1 id="3-流的使用"><a href="#3-流的使用" class="headerlink" title="3. 流的使用"></a>3. 流的使用</h1><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p>
<h2 id="3-1-流的构造与转换"><a href="#3-1-流的构造与转换" class="headerlink" title="3.1 流的构造与转换"></a>3.1 流的构造与转换</h2><ul>
<li>流的构造过程就是对原来的集合进行包装，产生一个Stream对象，常见的构造流的方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. Individual values</span></div><div class="line">Stream stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</div><div class="line"><span class="comment">// 2. Arrays</span></div><div class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</div><div class="line">stream = Stream.of(strArray);</div><div class="line">stream = Arrays.stream(strArray);</div><div class="line"><span class="comment">// 3. Collections</span></div><div class="line">List&lt;String&gt; list = Arrays.asList(strArray);</div><div class="line">stream = list.stream();</div></pre></td></tr></table></figure>
<ul>
<li>流转换为其它数据结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. Array</span></div><div class="line">String[] strArray1 = stream.toArray(String[]::<span class="keyword">new</span>);</div><div class="line"><span class="comment">// 2. Collection</span></div><div class="line">List&lt;String&gt; list1 = stream.collect(Collectors.toList());</div><div class="line">List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</div><div class="line">Set set1 = stream.collect(Collectors.toSet());</div><div class="line">Stack stack1 = stream.collect(Collectors.toCollection(Stack::<span class="keyword">new</span>));</div><div class="line"><span class="comment">// 3. String</span></div><div class="line">String str = stream.collect(Collectors.joining()).toString();</div></pre></td></tr></table></figure>
<p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。</p>
<h2 id="3-2-流的操作"><a href="#3-2-流的操作" class="headerlink" title="3.2 流的操作"></a>3.2 流的操作</h2><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p>
<ul>
<li><p>Intermediate：</p>
<p>  map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p>
</li>
<li><p>Terminal：</p>
<p>  forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p>
</li>
<li><p>Short-circuiting：</p>
<p>  anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limi</p>
</li>
</ul>
<p><strong>需要注意的是所有的操作方法可接受的参数都是lambda表达式（没有参数的操作方法除外）。</strong></p>
<h3 id="3-2-1-collect-toList"><a href="#3-2-1-collect-toList" class="headerlink" title="3.2.1 collect(toList())"></a>3.2.1 collect(toList())</h3><p>该操作是由Stream生成一个列表，是一个及时操作。</p>
<h3 id="3-2-2-map"><a href="#3-2-2-map" class="headerlink" title="3.2.2 map"></a>3.2.2 map</h3><p>map将一个流转化为一个新的流，是惰性操作。操作过程如下图所示：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/Java%208%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AStream-2.png" alt=""></p>
<p>下面是一个转换大小写的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; collected = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"hello"</span>)</div><div class="line">        .map(string -&gt; string.toUpperCase()) <span class="comment">//lambda</span></div><div class="line">        .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>注意：传给map的参数是一个lambda表达式，该lambda表达式必须是Function结构的实例，即lambda表达式只接受一个参数，并且返回一个值，接受参数类型和返回参数的类型可以不一样。Function接口如下图所示：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/Java%208%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AStream-3.png" alt=""></p>
<h3 id="3-2-3-flatMap"><a href="#3-2-3-flatMap" class="headerlink" title="3.2.3 flatMap"></a>3.2.3 flatMap</h3><p>Java 8中，除了一些基本的对象类型，如String，Object等，流也可以是集合或数组类型，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String[]&gt;</div><div class="line">Stream&lt;Set&lt;String&gt;&gt;</div><div class="line">Stream&lt;List&lt;String&gt;&gt;</div><div class="line">Stream&lt;List&lt;Object&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>然而，流的很多操作，如filter，sum，distinct等以及收集器collectors的处理都不支持这些流类型。因此需要使用flatmap对这些类型的流做转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String[]&gt;	-&gt; flatMap -&gt;	Stream&lt;String&gt;</div><div class="line">Stream&lt;Set&lt;String&gt;&gt;	-&gt; flatMap -&gt;	Stream&lt;String&gt;</div><div class="line">Stream&lt;List&lt;String&gt;&gt;	-&gt; flatMap -&gt;	Stream&lt;String&gt;</div><div class="line">Stream&lt;List&lt;Object&gt;&gt;	-&gt; flatMap -&gt;	Stream&lt;Object&gt;</div></pre></td></tr></table></figure>
<p>flapMap将这样的input Stream连接成一个新的Stream，实现了底层数据的扁平化处理，其操作过程如下图所示：</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/Java%208%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AStream-4.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</div><div class="line">        Arrays.asList(<span class="number">1</span>),</div><div class="line">        Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</div><div class="line">        Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div><div class="line">);</div><div class="line">Stream&lt;Integer&gt; outputStream = inputStream.</div><div class="line">        flatMap((childList) -&gt; childList.stream());</div><div class="line">List&lt;Integer&gt; collected = outputStream.collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p>上面的代码使用Strem的工厂方法，将每一个列表转换为Stream对象，然后使用flatMap方法将多个Stream转换为一个新的Stream。注意flapMap方法的相关函数接口和map方法一样，都是Function接口类型，只是方法的返回值限制为Stream类型罢了。</p>
<h3 id="3-2-4-filter"><a href="#3-2-4-filter" class="headerlink" title="3.2.4 filter"></a>3.2.4 filter</h3><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。filter接受的参数是一个Predicate类型的lambda表达式。</p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/Java%208%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AStream-5.png" alt=""></p>
<p>下面是用filter保留偶数的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Integer[] sixNums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</div><div class="line">Integer[] evens = Stream.of(sixNums)</div><div class="line">        .filter(n -&gt; n%<span class="number">2</span> == <span class="number">0</span>)</div><div class="line">        .toArray(Integer[]::<span class="keyword">new</span>);</div></pre></td></tr></table></figure>
<h3 id="3-2-5-findFirst"><a href="#3-2-5-findFirst" class="headerlink" title="3.2.5 findFirst"></a>3.2.5 findFirst</h3><p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。需要注意的是findFirst返回值的类型是Optional，Optional表示一个值的容器，它可能含有某值，可能不包含，使用它的目的是尽可能避免NullPointException。</p>
<p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p>
<h2 id="3-3-使用收集器"><a href="#3-3-使用收集器" class="headerlink" title="3.3 使用收集器"></a>3.3 使用收集器</h2><p>收集器是将流生成对应集合元素类型的方法，常用的收集器可从java.util.stream.Collectors中导入。例如Collectors.toList()就是一种从流生成对应列表的收集器，通过将收集器传递给collect方法，所有的流就可以使用它了。下面是使用收集器将流转化为其它类型集合的例子：</p>
<ul>
<li>使用toArray方法将String的流转化为对应的数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String[] strArray = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</div><div class="line">        .filter(x -&gt; x != String.valueOf(<span class="string">"b"</span>))</div><div class="line">        .toArray(String[]::<span class="keyword">new</span>);</div></pre></td></tr></table></figure>
<p>注意：toArray接收的函数接口类型或lambda表达式类型是IntFunction<a[]>，IntFunction如下图所示：</a[]></p>
<p><img src="http://oj37kd49l.bkt.clouddn.com/Java%208%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9AStream-6.png" alt=""></p>
<p>因此，上面的代码和下面的代码是等价的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String[] strArray = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</div><div class="line">        .filter(x -&gt; x != String.valueOf(<span class="string">"b"</span>))</div><div class="line">        .toArray(x -&gt; <span class="keyword">new</span> String[x]);</div></pre></td></tr></table></figure>
<ul>
<li>使用toCollection，用定制的集合收集元素，下面是将Stream收集成TreeSet集合的例子：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TreeSet&lt;String&gt; strSet = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"c"</span>)</div><div class="line">        .filter(x -&gt; x != String.valueOf(<span class="string">"b"</span>))</div><div class="line">        .collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</div></pre></td></tr></table></figure>
<p>这里，toCollection接收的函授接口类型是Supplier，Supplier表示lambda表达式不接收参数，但返回一个值，由于lambda表达式返回的类型可以根据上下文自动识别，所以这里当然返回的是一个TreeSet<string>的对象了。</string></p>
<p>参考：</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="external">Java 8 中的 Streams API 详解</a></p>
<p><a href="http://ifeve.com/stream/" target="_blank" rel="external">Java8初体验（二）Stream语法详解</a></p>
<p><a href="http://www.ituring.com.cn/book/1448" target="_blank" rel="external">Java 8函数式编程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;声明：本篇博客很多内容引用自&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/&quot;&gt;Java 8 中的 Streams API 详解&lt;/a&gt;和&lt;a href=&quot;http://www.ituring.com.cn/book/1448&quot;&gt;Java 8函数式编程&lt;/a&gt;，同时文中也有很多自己的理解和学习体会，希望通过这篇文章深入的介绍和总结Java 8的流式处理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java 8" scheme="http://yoursite.com/tags/Java-8/"/>
    
      <category term="Stream" scheme="http://yoursite.com/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 新特性：lambda表达式</title>
    <link href="http://yoursite.com/2016/12/03/java-8-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/12/03/java-8-新特性：lambda表达式/</id>
    <published>2016-12-03T12:32:57.000Z</published>
    <updated>2017-12-04T12:51:48.114Z</updated>
    
    <content type="html"><![CDATA[<p>lambda表达式是Java8带给我们的几个重量级特性之一，借用lambda表达式，可以让我们的Java程序设计更加简洁和高效。要深入理解lambda表达式，需要理解函数式接口，lambda表达式的表示形式，以及方法引用。</p>
<a id="more"></a>
<h1 id="1-函数式接口"><a href="#1-函数式接口" class="headerlink" title="1. 函数式接口"></a>1. 函数式接口</h1><p><strong>函数式接口是只有一个抽象方法的接口，用作lambda表达式的类型。</strong></p>
<p>函数式接口可以用@FunctionalInterface注解，可以把它放在注解的前面，但它是非必须的，使用注解只是为了方便编译器作语法检查。只要接口只包含一个抽象方法，虚拟机会自动判断。在接口中添加了 @FunctionalInterface 的注解后，该接口就只允许有一个抽象方法，否则编译器也会报错。如下，java.lang.Runnable 就是一个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>函数式接口的重要属性是：我们能够使用 lambda 实例化它们，lambda 表达式让你能够将函数作为方法参数，或者将代码作为数据对待。</strong></p>
<h1 id="2-lambda表达式"><a href="#2-lambda表达式" class="headerlink" title="2. lambda表达式"></a>2. lambda表达式</h1><p>lambda表达式是一种紧凑的传递行为的方式。lambda表达式由三部分组成：第一部分为一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数；第二部分为一个箭头符号：-&gt;；第三部分为方法体，可以是表达式和代码块。语法如下：</p>
<ul>
<li><p>方法体为表达式，该表达式的值作为返回值返回</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(parameters) -&gt; expression</div></pre></td></tr></table></figure>
<p>  例如：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;String&gt; i  = ()-&gt; <span class="string">"Supplier test"</span>;</div></pre></td></tr></table></figure>
<p>  这里，”Supplier test”就是lambda表达式i的get方法返回值。</p>
</li>
<li><p>方法体为代码块，必须用 {} 来包裹起来，且需要一个 return 返回值，但若函数式接口里面方法返回值是 void，则无需返回值。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(parameters) -&gt; &#123; statements; &#125;</div></pre></td></tr></table></figure>
<p>  例如上面的例子的等价形式为：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;String&gt; i  = ()-&gt; &#123;<span class="keyword">return</span>  <span class="string">"Supplier test"</span>;&#125;;</div></pre></td></tr></table></figure>
<p>  下面是匿名内部类的代码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">        System.out.print(<span class="string">"Hello lambda in actionPerformed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>  下面是使用lambda表达式后的代码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">button.addActionListener(</div><div class="line">    <span class="comment">//actionPerformed 有一个参数 e 传入，所以用 (ActionEvent e)</span></div><div class="line">    (ActionEvent e)-&gt; System.out.print(<span class="string">"Hello lambda in actionPerformed"</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>  其实，lambda表达式可以自己根据上下文推断参数类型，无需显示指定：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.addActionListener( e -&gt; System.out.print(<span class="string">"Hello lambda in actionPerformed"</span>));</div></pre></td></tr></table></figure>
</li>
<li><p>lambda表达式的几种变体<br>  将lambda表达式赋值给一个一个变量，lambda表达式没有参数：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Runnable noArguments = () -&gt; System.out.println(<span class="string">"Hello World"</span>); <span class="comment">//(1)</span></div></pre></td></tr></table></figure>
<p>  将lambda表达式赋值给一个一个变量，lambda表达式的参数类型由编译器推导出来：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ActionListener oneArgument = event -&gt; System.out.println(<span class="string">"button clicked"</span>); <span class="comment">//(2)</span></div></pre></td></tr></table></figure>
<p>  将lambda表达式赋值给一个一个变量，lambda表达式有多个参数类型，参数类型由编译器推导出来：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y; <span class="comment">//(3)</span></div></pre></td></tr></table></figure>
<p>   将lambda表达式赋值给一个一个变量，lambda表达式有多个参数类型，显示声明lambda表达式类型：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y; <span class="comment">//(4)</span></div></pre></td></tr></table></figure>
<p>  如上所示，有lambda表达式中的参数类型都是由编译器推断得出的。这当然不错，但有时最好也可以显式声明参数类型，此时就需要使用小括号将参数括起来，多个参数的情况也是如此,如(4)。 </p>
<p>  <strong>注意：</strong></p>
<p>  <strong>目标类型</strong>是指lambda表达式所在上下文环境的类型。比如，将lambda表达式赋值给一个局部变量，或传递给一个方法作为参数，局部变量或方法参数的类型就是lambda表达式的目标类型。lambda表达式的目标类型类型依赖于上下文环境，是由编译器推断出来的。如(1)和(2)的lambda表达式的目标类型分别是Runnable和ActionListener类型，可以把lambda表达式看作实现了该接口的内部类的实例，noArguments和oneArgument分表表示指向实例的引用。</p>
</li>
<li><p>lambda表达式能引用表达式之外定义的既成事实的final变量。虽然无需将变量声明为final，但在lambda表达式中，也无法用作非终态变量。下面的可以编译通过：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String name = getUserName();</div><div class="line">button.addActionListener(event -&gt; System.out.println(<span class="string">"hi"</span> + name));</div></pre></td></tr></table></figure>
<p>  但下面不能编译通过：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String name = getUserName();</div><div class="line">name = formatUserName(name);</div><div class="line">button.addActionListener(event -&gt; System.out.println(<span class="string">"hi"</span> + name));</div></pre></td></tr></table></figure>
<p>  也就是说，lambda只能引用表达式之外不会改变的变量，之所以有这样的限制，是因为若变量可以改变，并发执行多个lambda表达式时就会不安全。</p>
</li>
</ul>
<h1 id="3-方法引用"><a href="#3-方法引用" class="headerlink" title="3. 方法引用"></a>3. 方法引用</h1><p>可以用已经定义好的类中的方法来表示一个lambda表达式。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.addActionListener(event -&gt; System.out.println(event));</div></pre></td></tr></table></figure></p>
<p>可以使用System.out::println的方法引用表示成如下形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.addActionListener(System.out::println);</div></pre></td></tr></table></figure></p>
<p>总的来说，方法引用有如下四种使用情况：</p>
<ol>
<li>对象::实例方法</li>
<li>类::静态方法</li>
<li>类::实例方法</li>
<li>类::new</li>
</ol>
<p>在前两种情况，方法引用等同于提供方法参数的lambda表达式。如System.out::println等同于x -&gt; System.out.println(x)。类似的，Math::pow等同于(x, y) -&gt; Math.pow(x, y)。</p>
<p>第三种情况，<strong>第一个参数为执行方法的对象</strong>，即当lambda表达式的的第一个参数是要执行的方法体所属的对象时，可以使用<strong>类::实例方法</strong>的方法引用代替。例如：String::compareToIgnoreCase等同于(x, y) -&gt; x.compareToIgnoreCase(y)，这里x就是compareToIgnoreCase方法所属对象。其实这也是合理的，因为Java中实例方法拥有者为一个具体的对象，只有一个对象才能调用实例方法。</p>
<p>下面是一个具体的引用<strong>类::实例方法</strong>的例子，其中personList.stream().forEach(x -&gt; x.getName())和personList.stream().forEach(Person::getName)是等价的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String[] stringArray = &#123; <span class="string">"Barbara"</span>, <span class="string">"James"</span>, <span class="string">"Mary"</span>, <span class="string">"John"</span>,</div><div class="line">                <span class="string">"Patricia"</span>, <span class="string">"Robert"</span>, <span class="string">"Michael"</span>, <span class="string">"Linda"</span> &#125;;</div><div class="line">        <span class="comment">//Arrays.sort(stringArray, String::compareToIgnoreCase);</span></div><div class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>( String str : stringArray )</div><div class="line">            personList.add(<span class="keyword">new</span> Person(str));</div><div class="line">        <span class="comment">//personList.stream().forEach(x -&gt; x.getName());</span></div><div class="line">        personList.stream().forEach(Person::getName);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(name);</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第四种情况则是构造器的引用，对于拥有多个构造器的类，选择使用哪个引用取决于上下文。需要注意的是，虽然方法引用使用的是一个方法，但不需要在后面加括号，因为这里并不调用该方法。使用该方法只是提供了一种和lambda表达式等价的一种结构，在需要时才会调用。凡是使用lambda表达式的地方，就可以使用方法引用。 </p>
<p>方法引用还可以使用this或super参数，表示引用本类或父类中的方法，例如：this::equals就等同于x -&gt; this.equals(x)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentGreeter</span> <span class="keyword">extends</span> <span class="title">Greeter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span> <span class="params">()</span> </span>&#123;</div><div class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">super</span>::greet);</div><div class="line">        t.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello, world"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该例子中，相当于引用父类的方法，实现了一个这样的lambda表达式，返回类型为Runnable：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread t = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Hello, world"</span>));</div></pre></td></tr></table></figure></p>
<h1 id="4-什么时候使用Lambda表达式"><a href="#4-什么时候使用Lambda表达式" class="headerlink" title="4. 什么时候使用Lambda表达式"></a>4. 什么时候使用Lambda表达式</h1><p>函数式接口是lambda表达式的类型，因此，若函数的形参传递的是一个函数式接口类型的引用，则可以直接给该形参传递lambda表达式。当然，也可以给该形参传递实现该接口的匿名类对象或实例。下面的三种方法是等效的，当然，使用lambda表达式是最简洁的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.function.Consumer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"bay"</span>, <span class="string">"max"</span>, <span class="string">"huang"</span>);</div><div class="line">        list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                System.out.println(s);</div><div class="line">            &#125;</div><div class="line">        &#125;); <span class="comment">// 1: object of an anonymous class</span></div><div class="line">        list.forEach(<span class="keyword">new</span> InternalConsumer()); <span class="comment">// 2: normal object</span></div><div class="line">        list.forEach(System.out::println); <span class="comment">// 3: lambda</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalConsumer</span> <span class="keyword">implements</span> <span class="title">Consumer</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">            System.out.println(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="external">Method References</a></p>
<p><a href="http://www.java2s.com/Tutorials/Java/Java_Lambda/index.htm" target="_blank" rel="external">Java Lambda Introduction</a></p>
<p><a href="http://www.ituring.com.cn/book/1448" target="_blank" rel="external">Java 8函数式编程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;lambda表达式是Java8带给我们的几个重量级特性之一，借用lambda表达式，可以让我们的Java程序设计更加简洁和高效。要深入理解lambda表达式，需要理解函数式接口，lambda表达式的表示形式，以及方法引用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java 8" scheme="http://yoursite.com/tags/Java-8/"/>
    
      <category term="lambda表达式" scheme="http://yoursite.com/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 下通过apt-get安装JDK和Java IDE</title>
    <link href="http://yoursite.com/2016/12/02/Ubuntu-%E4%B8%8B%E9%80%9A%E8%BF%87apt-get%E5%AE%89%E8%A3%85JDK%E5%92%8CJava-IDE/"/>
    <id>http://yoursite.com/2016/12/02/Ubuntu-下通过apt-get安装JDK和Java-IDE/</id>
    <published>2016-12-02T06:30:56.000Z</published>
    <updated>2017-01-02T06:55:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux系统下做Java开发，安装JDK和Java IDE（如eclipse，idea）是必不可少的步骤。网上也有很多关于JDK配置的教程，但任然比较麻烦。下面将介绍在Ubuntu系统下使用在线包管理器apt-get快速安装JDK，eclipse和idea的方法。</p>
<a id="more"></a>
<h1 id="1-安装JDK"><a href="#1-安装JDK" class="headerlink" title="1. 安装JDK"></a>1. 安装JDK</h1><ol>
<li><p>安装OpenJDK</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install default-jre</div><div class="line">sudo apt-get install default-jdk</div></pre></td></tr></table></figure>
</li>
<li><p>安装Oracle JDK</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install software-properties-common -y</div><div class="line">sudo add-apt-repository ppa:webupd8team/java</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install oracle-java7-installer</div><div class="line">sudo apt-get install oracle-java7-set-default #安装自动设置java 7环境变量的包</div></pre></td></tr></table></figure>
</li>
<li><p>选择JDK版本</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo update-alternatives --config java</div><div class="line">sudo update-alternatives --config javac</div></pre></td></tr></table></figure>
<p> 上述命令会输出当前系统已安装的JDK版本和编号等信息，输入编号信息选择要使用的JDK版本，要维持当前值[*]按回车键。</p>
</li>
<li><p>查看JDK版本</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java -version</div><div class="line">javac -version</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="2-安装eclipse"><a href="#2-安装eclipse" class="headerlink" title="2. 安装eclipse"></a>2. 安装eclipse</h1><ol>
<li><p>添加ppa源</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-add-repository ppa:mmk2410/eclipse-ide-java</div><div class="line">sudo apt-get update</div></pre></td></tr></table></figure>
</li>
<li><p>查看eclipse版本</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-cache show eclipse-ide-java</div></pre></td></tr></table></figure>
</li>
<li><p>安装eclipse IDE</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install  eclipse-ide-java</div></pre></td></tr></table></figure>
</li>
<li><p>启动eclipse</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eclipse-ide</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：若安装了多个版本的eclipse，也可以通过 update-alternatives 选择指定的版本。</p>
<h1 id="3-安装Pydev等插件"><a href="#3-安装Pydev等插件" class="headerlink" title="3. 安装Pydev等插件"></a>3. 安装Pydev等插件</h1><p>一般高版本的eclipse java IDE自带Pydev插件，若某些版本的IDE没有带pydev插件，则需要手动安装。在线安装较缓慢，网上也有很多教程，下面介绍离线安装pydev插件的方法。</p>
<p>首先在<a href="https://sourceforge.net/projects/pydev/" target="_blank" rel="external">sourceforge</a>下载对应的pydev插件版本，然后解压.zip文件，将features和plugins里的文件拷贝到eclipse安装目录下的对应文件夹里即可。linux系统下eclipse的features和plugins文件夹在/usr/lib/eclipse目录下。</p>
<h1 id="3-安装idea社区版"><a href="#3-安装idea社区版" class="headerlink" title="3. 安装idea社区版"></a>3. 安装idea社区版</h1><p>idea社区版也可以通过apt-get在线安装，和eclipse类似，首先添加ppa软件源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:mmk2410/intellij-idea-community</div><div class="line">sudo apt-get update</div></pre></td></tr></table></figure>
<p>然后使用apt-get就可以安装了。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>ppa是Ubuntu Launchpad网站提供的一项服务，允许个人用户作为apt源供其他用户下载和更新，通常比Ubuntu中心提前出来，版本更新，满足大家及时的更新使用。当自己需要添加较新的apt源时，可到<a href="https://launchpad.net" target="_blank" rel="external">launchpad</a>搜索，并通过apt-add-repository命令添加ppa源。</p>
<p>ppa是linux发行版Debian系列的个人软件仓库，类似的还有RedHat系列的epel仓库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Linux系统下做Java开发，安装JDK和Java IDE（如eclipse，idea）是必不可少的步骤。网上也有很多关于JDK配置的教程，但任然比较麻烦。下面将介绍在Ubuntu系统下使用在线包管理器apt-get快速安装JDK，eclipse和idea的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="apt-get" scheme="http://yoursite.com/tags/apt-get/"/>
    
      <category term="JDK" scheme="http://yoursite.com/tags/JDK/"/>
    
      <category term="eclipse" scheme="http://yoursite.com/tags/eclipse/"/>
    
      <category term="idea" scheme="http://yoursite.com/tags/idea/"/>
    
      <category term="安装" scheme="http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>PXE服务和Cisco路由器上的DHCP配置</title>
    <link href="http://yoursite.com/2016/12/01/PXE%E6%9C%8D%E5%8A%A1%E5%92%8CCisco%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E7%9A%84DHCP%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2016/12/01/PXE服务和Cisco路由器上的DHCP配置/</id>
    <published>2016-12-01T07:23:02.000Z</published>
    <updated>2017-01-01T04:53:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>预启动执行环境（Preboot eXecution Environment，PXE，也被称为预执行环境）提供了一种使用网络接口（Network Interface）启动计算机的机制，这种机制让计算机的启动可以不依赖本地数据存储设备（如硬盘）或本地已安装的操作系统。</p>
<a id="more"></a>
<h1 id="PXE及其协议概述"><a href="#PXE及其协议概述" class="headerlink" title="PXE及其协议概述"></a>PXE及其协议概述</h1><p>PXE当初是作为Intel的有线管理体系的一部分，Intel 和 Systemsoft于1999年9月20日公布其规格(版本2.1)。通过使用像网际协议(IP)、用户数据报协议(UDP)、动态主机设定协定(DHCP)、小型文件传输协议(TFTP)等几种网络协议和全局唯一标识符(GUID)、通用网络驱动接口(UNDI)、通用唯一识别码(UUID)的概念并通过对客户机(通过PXE自检的电脑)固件扩展预设的API来实现目的。</p>
<p>PXE 协议大致上结合了DHCP和TFTP，虽然都有在两者上面有改进。DHCP用于查找合适的启动服务器,TFTP用于下载初始引导程序和附加文件。为了开始一个PXE自检会话，PXE固件广播一个带有明确的PXE选项DHCPDISCOVER包(扩展DHCPDISCOVER)到67/UDP端口(DHCP服务器端口)。PXE选项是PXE固件有PXE能力的鉴定，但是会被一般的DHCP服务忽略。当固件受到从这样的服务受到DHCPOFFER包时，它会通过要求其提供配置信息来自我配置。</p>
<h1 id="搭建PXE网络启动的服务"><a href="#搭建PXE网络启动的服务" class="headerlink" title="搭建PXE网络启动的服务"></a>搭建PXE网络启动的服务</h1><p>当经常需要系统恢复或系统安装时，搭建PXE网络启动服务是一个不错的选择。如何搭建PXE网络服务，在这里就不详细赘述，具体参考：</p>
<ul>
<li><a href="https://www.debian-administration.org/article/478/Setting_up_a_server_for_PXE_network_booting" target="_blank" rel="external">Setting up a server for PXE network booting</a></li>
<li><a href="https://linux.cn/article-4902-1.html" target="_blank" rel="external">RHEL/CentOS 7 中配置 PXE 网络启动服务器</a></li>
</ul>
<p>实际上，PXE网络启动服务就是DHCP服务器给客户系统分配IP地址以及客户系统通过TFTP获取服务器上的镜像文件的过程。因此，建立好TFTP服务后，DHCP服务器还要告知无盘启动的系统<strong>TFTP服务器的IP地址</strong>和<strong>镜像文件的名称</strong>。</p>
<p>DHCP作为引导启动协议bootp的升级版，仍然兼容boop协议，而bootp协议在设计之初就是为了使无盘启动的系统分配到ip并获得tftp服务器的镜像文件。bootp协议包的<strong>next-server</strong>和<strong>filename</strong>字段就是告知客户系统TFTP镜像服务的地址和镜像名称的过程。</p>
<h1 id="Cisco路由器上PXE网络启动的DHCP配置"><a href="#Cisco路由器上PXE网络启动的DHCP配置" class="headerlink" title="Cisco路由器上PXE网络启动的DHCP配置"></a>Cisco路由器上PXE网络启动的DHCP配置</h1><p>当前小编的公网环境已经支持PXE网络启动，只是小编的网络是一段使用了NAPT的内网，IP地址由Cisco路由器DHCP分配。因此，若要使用公网的PXE服务，需要在本地的DHCP服务器上引导PXE服务的镜像和地址。下面是Cisco路由器的相关配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ip dhcp pool vlan-name</div><div class="line">network net-address netmask</div><div class="line">bootfile filename</div><div class="line">next-server tftp-address</div><div class="line">default-router gateaway</div></pre></td></tr></table></figure></p>
<p>用wireshark抓DHCP Reply的包，就会发现next-server和bootfile相关字段的内容。</p>
<h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><p> 使用PXE启动时，发现有些设备会出现这样的错误：”PXE-E51 No DHCP or proxy DHCP offers were found or received” or “No proxy DHCP offers”，而使用笔记本连接在该设备所在的端口下时，能够正常启动。 这是因为一些网卡直到 MAC 层软件驱动被实际加载之后才会启动链路，而交换设备为了避免环路运行了STP协议，一个正常的交换接口从down到up要经过：Down，listening，learning，fowarding几个状态，一共耗时为30~50秒，从而决定此端口是blocking还是fowarding的，也是交换机的防止环路的机制。因此在dhcp过程中会出现超时现象。</p>
<p>解决这个问题的办法是将连接host的交换机端口设置为portfast状态，使得链路up时交换机端口直接进入forwarding状态，从而避免超时。基本配置方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Sw1(config)#spanning-tree portfast default %（所有接口启用）全局下用</div></pre></td></tr></table></figure></p>
<p>一般用在接入层的交换机上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Sw1(config-if)#spanning-tree portfast %单独启用特定接口</div><div class="line">Sw1(config-if)#spanning-tree portfast disable %（某个端口禁用，通常是连接另一台交换机的端口）</div></pre></td></tr></table></figure></p>
<p>关于portfast的详细信息参考如下连接：</p>
<ul>
<li><p><a href="http://www.bitscn.com/network/cisco/200806/142494.html" target="_blank" rel="external">思科交换机Portfast和Uplinkfast配置</a></p>
</li>
<li><p><a href="http://www.cisco.com/c/en/us/td/docs/switches/lan/catalyst4000/8-2glx/configuration/guide/stp_enha.html" target="_blank" rel="external">Configuring Spanning Tree PortFast, BPDU Guard, BPDU Filter, UplinkFast, BackboneFast, and Loop Guard</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;预启动执行环境（Preboot eXecution Environment，PXE，也被称为预执行环境）提供了一种使用网络接口（Network Interface）启动计算机的机制，这种机制让计算机的启动可以不依赖本地数据存储设备（如硬盘）或本地已安装的操作系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Sysadmin" scheme="http://yoursite.com/categories/Sysadmin/"/>
    
    
      <category term="PXE" scheme="http://yoursite.com/tags/PXE/"/>
    
      <category term="DHCP配置" scheme="http://yoursite.com/tags/DHCP%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看硬件设备信息</title>
    <link href="http://yoursite.com/2016/11/25/Linux%E6%9F%A5%E7%9C%8B%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2016/11/25/Linux查看硬件设备信息/</id>
    <published>2016-11-25T12:40:42.000Z</published>
    <updated>2017-03-05T06:19:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>硬件信息的查询和系统的内核和驱动相关，下面是在Linux系统下常用的查看硬件设备信息的方法。</p>
<a id="more"></a>
<ol>
<li><p><strong>PCI介绍</strong></p>
<p> PCI是Peripheral Component Interconnect(外设部件互连标准)的缩写，它是目前个人电脑中使用最为广泛的接口，几乎所有的主板产品上都带有这种插槽。PCI插槽也是主板带有最多数量的插槽类型，在目前流行的台式机主板上，ATX结构的主板一般带有5～6个PCI插槽，而小一点的MATX主板也都带有2～3个PCI插槽，可见其应用的广泛性。</p>
</li>
<li><p><strong>lspci</strong></p>
<p> lspci列出所有连接到 PCI 总线的详细信息，例如：显卡、网卡、USB 接口及 SATA 控制器等设备，<strong>该命令检查硬件设备不依赖于系统是否安装有该硬件对应的驱动模块</strong>。<br> <a href="http://superuser.com/questions/165733/will-lsusb-and-lspci-list-devices-for-which-the-system-has-no-drivers" target="_blank" rel="external">http://superuser.com/questions/165733/will-lsusb-and-lspci-list-devices-for-which-the-system-has-no-drivers</a></p>
<p> 常用的命令有：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lspci -v</div></pre></td></tr></table></figure>
<p> 结合lspci和/sys可以查询硬件使用的驱动信息。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$lspci</div><div class="line">...</div><div class="line">02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168B PCI Express Gigabit Ethernet controller (rev 01)</div><div class="line">$ find /sys | grep drivers.*02:00</div><div class="line">/sys/bus/pci/drivers/r8169/0000:02:00.0</div></pre></td></tr></table></figure>
<p> 可以看出使用的以太网卡的驱动是r8169。<br> <a href="http://unix.stackexchange.com/questions/41817/linux-how-to-find-the-device-driver-used-for-a-device" target="_blank" rel="external">http://unix.stackexchange.com/questions/41817/linux-how-to-find-the-device-driver-used-for-a-device</a></p>
</li>
<li><p><strong>dmidecode</strong></p>
<p> dmidecode，读取DMI表中的数据来提取硬件信息，可查看bios，cpu，memory等信息<br> 如sudo dmidecode -t memory可查看设备可支持的最大物理内存，当前内存大小，设备内存插槽个数及使用情况等。类似查看硬件信息的命令还有lshw：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo lshw -C net</div></pre></td></tr></table></figure>
</li>
<li><p><strong>lscpu</strong></p>
<p> 列出cpu信息，如：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[optnetlab@ustc ~]$ lscpu</div><div class="line">Architecture:          x86_64                   #cpu构架</div><div class="line">CPU op-mode(s):        32-bit, 64-bit           #支持的操作系统 </div><div class="line">Byte Order:            Little Endian</div><div class="line">CPU(s):                4                        #逻辑CPU个数</div><div class="line">On-line CPU(s) list:   0-3                      #可使用的逻辑CPU</div><div class="line">Thread(s) per core:    2                        #每个核的线程数</div><div class="line">Core(s) per socket:    2                        #每个cpu插槽核数/每颗物理cpu核数是2</div><div class="line">Socket(s):             1                        #CPU插槽个数</div><div class="line">NUMA node(s):          1</div><div class="line">Vendor ID:             GenuineIntel</div><div class="line">CPU family:            6</div><div class="line">Model:                 42</div><div class="line">Stepping:              7</div><div class="line">CPU MHz:               1600.000                 #CPU主频</div><div class="line">BogoMIPS:              6584.65</div><div class="line">Virtualization:        VT-x                     #CPU支持虚拟化</div><div class="line">L1d cache:             32K                      #L1缓存</div><div class="line">L1i cache:             32K</div><div class="line">L2 cache:              256K</div><div class="line">L3 cache:              3072K</div><div class="line">NUMA node0 CPU(s):     0-3</div></pre></td></tr></table></figure>
<p> 类似的还有lsusb</p>
</li>
<li><p><strong>fdisk和df</strong></p>
<p> fdisk和df分别用来查看磁盘分区和文件系统的信息。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fdisk -l</div><div class="line">df -hT</div></pre></td></tr></table></figure>
</li>
<li><p><strong>其它常用命令</strong></p>
<p> 查看系统物理内存及交换分区信息:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">free -h</div></pre></td></tr></table></figure>
<p> 查看cpu或memory信息：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /proc/cpuinf</div><div class="line">cat /proc/meminf</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;硬件信息的查询和系统的内核和驱动相关，下面是在Linux系统下常用的查看硬件设备信息的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Sysadmin" scheme="http://yoursite.com/categories/Sysadmin/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="设备信息" scheme="http://yoursite.com/tags/%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
</feed>
